// Generated by Haxe 3.4.4
(function ($global) { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var List = function() {
	this.length = 0;
};
List.__name__ = true;
List.prototype = {
	add: function(item) {
		var x = new _$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,first: function() {
		if(this.h == null) {
			return null;
		} else {
			return this.h.item;
		}
	}
	,last: function() {
		if(this.q == null) {
			return null;
		} else {
			return this.q.item;
		}
	}
	,toString: function() {
		var s_b = "";
		var first = true;
		var l = this.h;
		s_b += "{";
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += ", ";
			}
			s_b += Std.string(Std.string(l.item));
			l = l.next;
		}
		s_b += "}";
		return s_b;
	}
	,join: function(sep) {
		var s_b = "";
		var first = true;
		var l = this.h;
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += sep == null ? "null" : "" + sep;
			}
			s_b += Std.string(l.item);
			l = l.next;
		}
		return s_b;
	}
	,__class__: List
};
var _$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
_$List_ListNode.__name__ = true;
_$List_ListNode.prototype = {
	__class__: _$List_ListNode
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds__$HashMap_HashMapData = function() {
	this.keys = new haxe_ds_IntMap();
	this.values = new haxe_ds_IntMap();
};
haxe_ds__$HashMap_HashMapData.__name__ = true;
haxe_ds__$HashMap_HashMapData.prototype = {
	__class__: haxe_ds__$HashMap_HashMapData
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_ds__$Vector_Vector_$Impl_$ = {};
haxe_ds__$Vector_Vector_$Impl_$.__name__ = true;
haxe_ds__$Vector_Vector_$Impl_$.blit = function(src,srcPos,dest,destPos,len) {
	if(src == dest) {
		if(srcPos < destPos) {
			var i = srcPos + len;
			var j = destPos + len;
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var k = _g1++;
				--i;
				--j;
				src[j] = src[i];
			}
		} else if(srcPos > destPos) {
			var i1 = srcPos;
			var j1 = destPos;
			var _g11 = 0;
			var _g2 = len;
			while(_g11 < _g2) {
				var k1 = _g11++;
				src[j1] = src[i1];
				++i1;
				++j1;
			}
		}
	} else {
		var _g12 = 0;
		var _g3 = len;
		while(_g12 < _g3) {
			var i2 = _g12++;
			dest[destPos + i2] = src[srcPos + i2];
		}
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__cast = function(o,t) {
	if(js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new js__$Boot_HaxeError("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var kretha_Clade = function() {
	this.mDistStretch = 20;
	this.mLineTextDist = 3;
	this.mBorder = 20;
	this.mLineWidth = 1;
	this.mTextSize = 14;
	this.mTextDist = 5;
	this.mCladeDist = 5;
	this.mColor = "black";
	this.mDist = 0;
	this.mChilds = new List();
	this.mInfo = new List();
	this.mConnectedInfo = new haxe_ds_StringMap();
};
kretha_Clade.__name__ = true;
kretha_Clade.prototype = {
	colorfy: function(color) {
		this.mColor = color;
		var _g_head = this.mChilds.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var child = val;
			child.colorfy(color);
		}
	}
	,setParent: function(clade,dist) {
		this.mParent = clade;
		this.mDist = dist;
		clade.mChilds.add(this);
	}
	,getChilds: function() {
		return this.mChilds;
	}
	,addInfo: function(info) {
		this.mInfo.add(info);
	}
	,isTerminal: function() {
		return this.mChilds.length == 0;
	}
	,isRoot: function() {
		return this.mParent == null;
	}
	,calcSize: function(useCache) {
		if(useCache && this.mLastSizeCalc != null) {
			return this.mLastSizeCalc;
		}
		var w = 0;
		var h = 0;
		if(this.mChilds.length == 0) {
			var maxInfoLen = 0;
			var _g_head = this.mInfo.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var info = val;
				if(maxInfoLen > info.length) {
					maxInfoLen = maxInfoLen;
				} else {
					maxInfoLen = info.length;
				}
			}
			w = this.mDist * this.mDistStretch + this.mLineTextDist + maxInfoLen * this.mTextSize;
			if(this.mInfo.length == 0) {
				h = this.mCladeDist << 1;
			} else {
				h = this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 1);
			}
		} else {
			var _g_head1 = this.mChilds.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var child = val1;
				var childInfo = child.calcSize(useCache);
				if(w > childInfo.w) {
					w = w;
				} else {
					w = childInfo.w;
				}
				h += childInfo.h;
			}
			w += this.mDist * this.mDistStretch;
			h += this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 2);
		}
		this.mLastSizeCalc = { w : w, h : h};
		return this.mLastSizeCalc;
	}
	,getSVG: function() {
		var result = [];
		var w = 0;
		var h = 0;
		if(this.mChilds.length == 0) {
			var maxInfoLen = 0;
			var _g_head = this.mInfo.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var info = val;
				if(maxInfoLen > info.length) {
					maxInfoLen = maxInfoLen;
				} else {
					maxInfoLen = info.length;
				}
			}
			w = this.mDist * this.mDistStretch + this.mLineTextDist + maxInfoLen * this.mTextSize;
			if(this.mInfo.length == 0) {
				h = this.mCladeDist << 1;
			} else {
				h = this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 1);
			}
		} else {
			var _g_head1 = this.mChilds.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var child = val1;
				var childInfo = child.calcSize(false);
				if(w > childInfo.w) {
					w = w;
				} else {
					w = childInfo.w;
				}
				h += childInfo.h;
			}
			w += this.mDist * this.mDistStretch;
			h += this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 2);
		}
		this.mLastSizeCalc = { w : w, h : h};
		var dim = this.mLastSizeCalc;
		result.push("<svg version='1.1' baseProfile='full' width='" + (2 * this.mBorder + 200 + dim.w) + "' height='" + (2 * this.mBorder + dim.h) + "' xmlns='http://www.w3.org/2000/svg'>");
		result.push("<g style='stroke:" + this.mColor + ";stroke-width:" + this.mLineWidth + "' font-family='Courier New' font-size='" + this.mTextSize + "'>");
		this.paint(result,this.mBorder,this.mBorder,this.mColor);
		result.push("</g>");
		result.push("</svg>");
		return result.join("");
	}
	,paint: function(result,x,y,color) {
		var resX = 0;
		var resY = 0;
		var finalY = 0;
		result.push("<g id='" + this.mInfo.first() + "' style='stroke:" + this.mColor + "'>");
		if(this.mChilds.length == 0) {
			var dim;
			if(this.mLastSizeCalc != null) {
				dim = this.mLastSizeCalc;
			} else {
				var w = 0;
				var h = 0;
				if(this.mChilds.length == 0) {
					var maxInfoLen = 0;
					var _g_head = this.mInfo.h;
					while(_g_head != null) {
						var val = _g_head.item;
						_g_head = _g_head.next;
						var info = val;
						if(maxInfoLen > info.length) {
							maxInfoLen = maxInfoLen;
						} else {
							maxInfoLen = info.length;
						}
					}
					w = this.mDist * this.mDistStretch + this.mLineTextDist + maxInfoLen * this.mTextSize;
					if(this.mInfo.length == 0) {
						h = this.mCladeDist << 1;
					} else {
						h = this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 1);
					}
				} else {
					var _g_head1 = this.mChilds.h;
					while(_g_head1 != null) {
						var val1 = _g_head1.item;
						_g_head1 = _g_head1.next;
						var child = val1;
						var childInfo = child.calcSize(true);
						if(w > childInfo.w) {
							w = w;
						} else {
							w = childInfo.w;
						}
						h += childInfo.h;
					}
					w += this.mDist * this.mDistStretch;
					h += this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 2);
				}
				this.mLastSizeCalc = { w : w, h : h};
				dim = this.mLastSizeCalc;
			}
			finalY = dim.h + y;
			var mx = x;
			var my = y + dim.h / 2;
			result.push("<line x1='" + mx + "' y1='" + my + "' x2='" + (mx + this.mDist * this.mDistStretch) + "' y2='" + my + "' title='" + this.mDist + "'/>");
			resX = mx;
			resY = my;
			mx = x + this.mDist * this.mDistStretch + this.mLineTextDist;
			my = y + this.mCladeDist + this.mTextSize / 2 + 2.5;
			var _g_head2 = this.mInfo.h;
			while(_g_head2 != null) {
				var val2 = _g_head2.item;
				_g_head2 = _g_head2.next;
				var info1 = val2;
				result.push("<text x='" + mx + "' y='" + my + "'>" + info1 + "</text>");
				my += this.mTextSize + this.mTextDist;
			}
		} else {
			var dim1;
			if(this.mLastSizeCalc != null) {
				dim1 = this.mLastSizeCalc;
			} else {
				var w1 = 0;
				var h1 = 0;
				if(this.mChilds.length == 0) {
					var maxInfoLen1 = 0;
					var _g_head3 = this.mInfo.h;
					while(_g_head3 != null) {
						var val3 = _g_head3.item;
						_g_head3 = _g_head3.next;
						var info2 = val3;
						if(maxInfoLen1 > info2.length) {
							maxInfoLen1 = maxInfoLen1;
						} else {
							maxInfoLen1 = info2.length;
						}
					}
					w1 = this.mDist * this.mDistStretch + this.mLineTextDist + maxInfoLen1 * this.mTextSize;
					if(this.mInfo.length == 0) {
						h1 = this.mCladeDist << 1;
					} else {
						h1 = this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 1);
					}
				} else {
					var _g_head4 = this.mChilds.h;
					while(_g_head4 != null) {
						var val4 = _g_head4.item;
						_g_head4 = _g_head4.next;
						var child1 = val4;
						var childInfo1 = child1.calcSize(true);
						if(w1 > childInfo1.w) {
							w1 = w1;
						} else {
							w1 = childInfo1.w;
						}
						h1 += childInfo1.h;
					}
					w1 += this.mDist * this.mDistStretch;
					h1 += this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 2);
				}
				this.mLastSizeCalc = { w : w1, h : h1};
				dim1 = this.mLastSizeCalc;
			}
			finalY = dim1.h + y;
			var mx1 = x;
			var my1 = y + dim1.h / 2;
			result.push("<line x1='" + mx1 + "' y1='" + my1 + "' x2='" + (mx1 + this.mDist * this.mDistStretch) + "' y2='" + my1 + "' title='" + this.mDist + "'/>");
			resX = mx1;
			resY = my1;
			var h2 = this.mCladeDist;
			var lowestY = -1;
			var highestY = -1;
			var txtY = -1;
			var _g_head5 = this.mChilds.h;
			while(_g_head5 != null) {
				var val5 = _g_head5.item;
				_g_head5 = _g_head5.next;
				var child2 = val5;
				var childDim;
				if(child2.mLastSizeCalc != null) {
					childDim = child2.mLastSizeCalc;
				} else {
					var w2 = 0;
					var h3 = 0;
					if(child2.mChilds.length == 0) {
						var maxInfoLen2 = 0;
						var _g_head6 = child2.mInfo.h;
						while(_g_head6 != null) {
							var val6 = _g_head6.item;
							_g_head6 = _g_head6.next;
							var info3 = val6;
							if(maxInfoLen2 > info3.length) {
								maxInfoLen2 = maxInfoLen2;
							} else {
								maxInfoLen2 = info3.length;
							}
						}
						w2 = child2.mDist * child2.mDistStretch + child2.mLineTextDist + maxInfoLen2 * child2.mTextSize;
						if(child2.mInfo.length == 0) {
							h3 = child2.mCladeDist << 1;
						} else {
							h3 = child2.mInfo.length * child2.mTextSize + (child2.mInfo.length - 1) * child2.mTextDist + (child2.mCladeDist << 1);
						}
					} else {
						var _g_head7 = child2.mChilds.h;
						while(_g_head7 != null) {
							var val7 = _g_head7.item;
							_g_head7 = _g_head7.next;
							var child3 = val7;
							var childInfo2 = child3.calcSize(true);
							if(w2 > childInfo2.w) {
								w2 = w2;
							} else {
								w2 = childInfo2.w;
							}
							h3 += childInfo2.h;
						}
						w2 += child2.mDist * child2.mDistStretch;
						h3 += child2.mInfo.length * child2.mTextSize + (child2.mInfo.length - 1) * child2.mTextDist + (child2.mCladeDist << 2);
					}
					child2.mLastSizeCalc = { w : w2, h : h3};
					childDim = child2.mLastSizeCalc;
				}
				var midPoint = child2.paint(result,x + this.mDist * this.mDistStretch,y + h2,this.mColor);
				if(txtY != -1) {
					txtY = txtY;
				} else {
					txtY = midPoint.finalY;
				}
				if(lowestY != -1 && lowestY < midPoint.y) {
					lowestY = lowestY;
				} else {
					lowestY = midPoint.y;
				}
				if(highestY > midPoint.y) {
					highestY = highestY;
				} else {
					highestY = midPoint.y;
				}
				h2 += childDim.h + this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist;
			}
			mx1 += this.mDist * this.mDistStretch;
			result.push("<line x1='" + mx1 + "' y1='" + lowestY + "' x2='" + mx1 + "' y2='" + highestY + "' title='" + this.mDist + "'/>");
			mx1 += this.mLineTextDist;
			my1 = txtY + this.mCladeDist + this.mTextSize / 2 + 2.5;
			var _g_head8 = this.mInfo.h;
			while(_g_head8 != null) {
				var val8 = _g_head8.item;
				_g_head8 = _g_head8.next;
				var info4 = val8;
				result.push("<text x='" + mx1 + "' y='" + my1 + "'>" + info4 + "</text>");
				my1 += this.mTextSize + this.mTextDist;
			}
		}
		result.push("</g>");
		return { x : resX, y : resY, finalY : finalY};
	}
	,getTextRepresentation: function(result,indent) {
		var _g1 = 0;
		var _g = indent;
		while(_g1 < _g) {
			var i = _g1++;
			result.push("  ");
		}
		result.push("Clade(" + this.mDist + ", " + this.mColor + ";" + Std.string(this.mInfo) + ")\n");
		var _g_head = this.mChilds.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var clade = val;
			clade.getTextRepresentation(result,indent + 1);
		}
	}
	,toString: function() {
		var result = [];
		this.getTextRepresentation(result,0);
		return result.join("");
	}
	,toString_: function() {
		var result = [];
		result.push("Clade(" + this.mInfo.join(",") + ")");
		result.push("  parent: " + (this.mParent == null ? "null" : this.mParent.mInfo.join(",")));
		result.push("  childs: " + this.mChilds.length);
		return result.join("");
	}
	,__class__: kretha_Clade
};
var kretha_Matrix = function(w,h) {
	if(w < 1) {
		throw new js__$Boot_HaxeError("Width must be bigger then 0!");
	}
	if(h < 1) {
		throw new js__$Boot_HaxeError("Height must be bigger then 0!");
	}
	this.mWidth = w;
	this.mHeight = h;
	var this1 = new Array(w * h);
	this.mValues = this1;
};
kretha_Matrix.__name__ = true;
kretha_Matrix.prototype = {
	getWidth: function() {
		return this.mWidth;
	}
	,getHeight: function() {
		return this.mHeight;
	}
	,getValue: function(x,y) {
		if(0 > x || x >= this.mWidth || 0 > y || y >= this.mHeight) {
			throw new js__$Boot_HaxeError("x or y (" + x + "," + y + ") out of range!");
		}
		return this.mValues[x + y * this.mWidth];
	}
	,setValue: function(x,y,val) {
		if(0 > x || x >= this.mWidth || 0 > y || y >= this.mHeight) {
			throw new js__$Boot_HaxeError("x or y (" + x + "," + y + ") out of range!");
		}
		this.mValues[x + y * this.mWidth] = val;
	}
	,toString: function() {
		var result = [];
		result.push("Matrix(" + this.mWidth + "," + this.mHeight + ")\n");
		var _g1 = 0;
		var _g = this.mHeight;
		while(_g1 < _g) {
			var j = _g1++;
			var _g3 = 0;
			var _g2 = this.mWidth;
			while(_g3 < _g2) {
				var i = _g3++;
				if(i != 0) {
					result.push("\t");
				}
				if(0 > i || i >= this.mWidth || 0 > j || j >= this.mHeight) {
					throw new js__$Boot_HaxeError("x or y (" + i + "," + j + ") out of range!");
				}
				result.push("" + this.mValues[i + j * this.mWidth]);
			}
			result.push("\n");
		}
		return result.join("");
	}
	,__class__: kretha_Matrix
};
var kretha_DistanceMatrix = function(names) {
	if(names == null || names.length == 0) {
		throw new js__$Boot_HaxeError("Names must not be empty!");
	}
	kretha_Matrix.call(this,names.length,names.length);
	this.mNames = names;
	var this1 = new haxe_ds__$HashMap_HashMapData();
	this.mNamePosLookup = this1;
	var pos = 0;
	var _g = 0;
	while(_g < names.length) {
		var name = names[_g];
		++_g;
		var this2 = this.mNamePosLookup;
		var _this = this2.keys;
		var key = name.hashCode();
		_this.h[key] = name;
		var _this1 = this2.values;
		var key1 = name.hashCode();
		_this1.h[key1] = pos++;
	}
};
kretha_DistanceMatrix.__name__ = true;
kretha_DistanceMatrix.__super__ = kretha_Matrix;
kretha_DistanceMatrix.prototype = $extend(kretha_Matrix.prototype,{
	getNames: function() {
		return this.mNames;
	}
	,lookup: function(x1,x2) {
		var ret = 0;
		if(x1 != x2) {
			var _this = this.mNamePosLookup.values;
			var key = x1.hashCode();
			var pos1 = _this.h[key];
			if(pos1 == null) {
				throw new js__$Boot_HaxeError(Std.string(x1) + " not in map!");
			}
			var _this1 = this.mNamePosLookup.values;
			var key1 = x2.hashCode();
			var pos2 = _this1.h[key1];
			if(pos2 == null) {
				throw new js__$Boot_HaxeError(Std.string(x2) + " not in map!");
			}
			if(pos1 > pos2) {
				var swap = pos1;
				pos1 = pos2;
				pos2 = swap;
			}
			ret = this.mValues[pos1 + pos2 * this.mWidth];
		}
		return ret;
	}
	,set: function(x1,x2,d) {
		if(x1 == x2) {
			if(d != 0) {
				throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
			}
		}
		var _this = this.mNamePosLookup.values;
		var key = x1.hashCode();
		var pos1 = _this.h[key];
		if(pos1 == null) {
			throw new js__$Boot_HaxeError(Std.string(x1) + " not in map!");
		}
		var _this1 = this.mNamePosLookup.values;
		var key1 = x2.hashCode();
		var pos2 = _this1.h[key1];
		if(pos2 == null) {
			throw new js__$Boot_HaxeError(Std.string(x2) + " not in map!");
		}
		if(pos1 > pos2) {
			var swap = pos1;
			pos1 = pos2;
			pos2 = swap;
		}
		this.mValues[pos1 + pos2 * this.mWidth] = d;
	}
	,toString: function() {
		var result = [];
		result.push("Dist");
		var _g = 0;
		var _g1 = this.mNames;
		while(_g < _g1.length) {
			var name = _g1[_g];
			++_g;
			result.push("\t" + Std.string(name));
		}
		result.push("\n");
		var x = 0;
		var _g2 = 0;
		var _g11 = this.mNames;
		while(_g2 < _g11.length) {
			var name1 = _g11[_g2];
			++_g2;
			result.push(Std.string(name1));
			var y = 0;
			var _g21 = 0;
			var _g3 = this.mNames;
			while(_g21 < _g3.length) {
				var name2 = _g3[_g21];
				++_g21;
				if(y >= x) {
					break;
				}
				result.push("\t" + this.mValues[y + x * this.mWidth]);
				++y;
			}
			result.push("\n");
			++x;
		}
		return result.join("");
	}
	,__class__: kretha_DistanceMatrix
});
var kretha_IAlignmentReader = function() { };
kretha_IAlignmentReader.__name__ = true;
kretha_IAlignmentReader.prototype = {
	__class__: kretha_IAlignmentReader
};
var kretha_FastaAlignmentReader = function() {
};
kretha_FastaAlignmentReader.__name__ = true;
kretha_FastaAlignmentReader.__interfaces__ = [kretha_IAlignmentReader];
kretha_FastaAlignmentReader.prototype = {
	readSequences: function(fileContent) {
		var sequences = [];
		var lines = fileContent.split("\n");
		var name = null;
		var seq = null;
		var seqAlreadySeen = new haxe_ds_StringMap();
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			line = StringTools.trim(line);
			if(line == "" || line.charAt(0) == ";" || line.charAt(0) == "#") {
				continue;
			}
			if(line.charAt(0) == ">") {
				if(name != null) {
					if(__map_reserved[seq] != null ? seqAlreadySeen.existsReserved(seq) : seqAlreadySeen.h.hasOwnProperty(seq)) {
						var s = __map_reserved[seq] != null ? seqAlreadySeen.getReserved(seq) : seqAlreadySeen.h[seq];
						s.mNames.add(name);
					} else {
						var l = new List();
						l.add(name);
						var s1 = new kretha_Sequence(l,seq);
						if(__map_reserved[seq] != null) {
							seqAlreadySeen.setReserved(seq,s1);
						} else {
							seqAlreadySeen.h[seq] = s1;
						}
						sequences.push(s1);
					}
				}
				name = StringTools.trim(HxOverrides.substr(line,1,null));
				seq = "";
			} else {
				seq += line;
			}
		}
		if(name != null) {
			if(__map_reserved[seq] != null ? seqAlreadySeen.existsReserved(seq) : seqAlreadySeen.h.hasOwnProperty(seq)) {
				var s2 = __map_reserved[seq] != null ? seqAlreadySeen.getReserved(seq) : seqAlreadySeen.h[seq];
				s2.mNames.add(name);
			} else {
				var l1 = new List();
				l1.add(name);
				var s3 = new kretha_Sequence(l1,seq);
				if(__map_reserved[seq] != null) {
					seqAlreadySeen.setReserved(seq,s3);
				} else {
					seqAlreadySeen.h[seq] = s3;
				}
				sequences.push(s3);
			}
		}
		var length = sequences.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g1 = 0;
		while(_g1 < sequences.length) {
			var sequence = sequences[_g1];
			++_g1;
			result[i++] = sequence;
		}
		return result;
	}
	,__class__: kretha_FastaAlignmentReader
};
var kretha_FourTimesRule = function() { };
kretha_FourTimesRule.__name__ = true;
kretha_FourTimesRule.calcPairwiseDifference = function(a1,a2) {
	if((a2.mSeq == null ? 0 : a2.mSeq.length) != (a1.mSeq == null ? 0 : a1.mSeq.length)) {
		throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
	}
	var score = 0;
	var _g1 = 0;
	var _g = a1.mSeq == null ? 0 : a1.mSeq.length;
	while(_g1 < _g) {
		var i = _g1++;
		var c1 = a1.mSeq.charAt(i);
		var c2 = a2.mSeq.charAt(i);
		if(c1 != c2) {
			++score;
		}
	}
	var res = score;
	return res / (a1.mSeq == null ? 0 : a1.mSeq.length);
};
kretha_FourTimesRule.calcPairwiseDistance = function(seqs) {
	var count = 0;
	var diff = 0;
	var c = 0;
	var _g_head = seqs.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var seq1 = val;
		var _g1 = 0;
		var _g = seq1.mNames.length;
		while(_g1 < _g) {
			var i = _g1++;
			var d = 0;
			var _g2_head = seqs.h;
			while(_g2_head != null) {
				var val1 = _g2_head.item;
				_g2_head = _g2_head.next;
				var seq2 = val1;
				var _g3 = 0;
				var _g2 = seq2.mNames.length;
				while(_g3 < _g2) {
					var j = _g3++;
					if(c == d) {
						++d;
						continue;
					}
					++count;
					if((seq2.mSeq == null ? 0 : seq2.mSeq.length) != (seq1.mSeq == null ? 0 : seq1.mSeq.length)) {
						throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
					}
					var score = 0;
					var _g11 = 0;
					var _g4 = seq1.mSeq == null ? 0 : seq1.mSeq.length;
					while(_g11 < _g4) {
						var i1 = _g11++;
						var c1 = seq1.mSeq.charAt(i1);
						var c2 = seq2.mSeq.charAt(i1);
						if(c1 != c2) {
							++score;
						}
					}
					var res = score;
					diff += res / (seq1.mSeq == null ? 0 : seq1.mSeq.length);
					++d;
				}
			}
			++c;
		}
	}
	if(count == 0) {
		return 0;
	}
	return diff / count;
};
kretha_FourTimesRule.calcPairwiseDistanceOfSubClades = function(seqsA,seqsB) {
	var comparisons = 0;
	var diff = 0;
	var _g_head = seqsA.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var seq1 = val;
		var _g_head1 = seqsB.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var seq2 = val1;
			var _g1 = 0;
			var _g = seq1.mNames.length;
			while(_g1 < _g) {
				var i = _g1++;
				var _g3 = 0;
				var _g2 = seq2.mNames.length;
				while(_g3 < _g2) {
					var j = _g3++;
					++comparisons;
					if((seq2.mSeq == null ? 0 : seq2.mSeq.length) != (seq1.mSeq == null ? 0 : seq1.mSeq.length)) {
						throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
					}
					var score = 0;
					var _g11 = 0;
					var _g4 = seq1.mSeq == null ? 0 : seq1.mSeq.length;
					while(_g11 < _g4) {
						var i1 = _g11++;
						var c1 = seq1.mSeq.charAt(i1);
						var c2 = seq2.mSeq.charAt(i1);
						if(c1 != c2) {
							++score;
						}
					}
					var res = score;
					diff += res / (seq1.mSeq == null ? 0 : seq1.mSeq.length);
				}
			}
		}
	}
	return diff / comparisons;
};
kretha_FourTimesRule.calcTheta = function(seqs,c) {
	var n = 0;
	var _g_head = seqs.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var seq = val;
		n += seq.mNames.length;
	}
	var count = 0;
	var diff = 0;
	var c1 = 0;
	var _g_head1 = seqs.h;
	while(_g_head1 != null) {
		var val1 = _g_head1.item;
		_g_head1 = _g_head1.next;
		var seq1 = val1;
		var _g1 = 0;
		var _g = seq1.mNames.length;
		while(_g1 < _g) {
			var i = _g1++;
			var d = 0;
			var _g2_head = seqs.h;
			while(_g2_head != null) {
				var val2 = _g2_head.item;
				_g2_head = _g2_head.next;
				var seq2 = val2;
				var _g3 = 0;
				var _g2 = seq2.mNames.length;
				while(_g3 < _g2) {
					var j = _g3++;
					if(c1 == d) {
						++d;
						continue;
					}
					++count;
					if((seq2.mSeq == null ? 0 : seq2.mSeq.length) != (seq1.mSeq == null ? 0 : seq1.mSeq.length)) {
						throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
					}
					var score = 0;
					var _g11 = 0;
					var _g4 = seq1.mSeq == null ? 0 : seq1.mSeq.length;
					while(_g11 < _g4) {
						var i1 = _g11++;
						var c11 = seq1.mSeq.charAt(i1);
						var c2 = seq2.mSeq.charAt(i1);
						if(c11 != c2) {
							++score;
						}
					}
					var res = score;
					diff += res / (seq1.mSeq == null ? 0 : seq1.mSeq.length);
					++d;
				}
			}
			++c1;
		}
	}
	var pairwiseDistance = count == 0 ? 0 : diff / count;
	var pi = 0;
	if(pairwiseDistance == 0) {
		var _this = seqs.first();
		var seqLen = _this.mSeq == null ? 0 : _this.mSeq.length;
		pairwiseDistance = 1 / seqLen;
	}
	if(n == 1) {
		n = 2;
	}
	pi = pairwiseDistance * n / (n - 1);
	return pi / (1 - 4 * pi / 3);
};
kretha_FourTimesRule.getBestSubClades = function(subCladeA,subCladeB,c) {
	var best = Infinity;
	var a = null;
	var b = null;
	var _g_head = subCladeA.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var spSA = val;
		var _g_head1 = subCladeB.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var spSB = val1;
			var comparisons = 0;
			var diff = 0;
			var _g_head2 = spSA.h;
			while(_g_head2 != null) {
				var val2 = _g_head2.item;
				_g_head2 = _g_head2.next;
				var seq1 = val2;
				var _g_head3 = spSB.h;
				while(_g_head3 != null) {
					var val3 = _g_head3.item;
					_g_head3 = _g_head3.next;
					var seq2 = val3;
					var _g1 = 0;
					var _g = seq1.mNames.length;
					while(_g1 < _g) {
						var i = _g1++;
						var _g3 = 0;
						var _g2 = seq2.mNames.length;
						while(_g3 < _g2) {
							var j = _g3++;
							++comparisons;
							if((seq2.mSeq == null ? 0 : seq2.mSeq.length) != (seq1.mSeq == null ? 0 : seq1.mSeq.length)) {
								throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
							}
							var score = 0;
							var _g11 = 0;
							var _g4 = seq1.mSeq == null ? 0 : seq1.mSeq.length;
							while(_g11 < _g4) {
								var i1 = _g11++;
								var c1 = seq1.mSeq.charAt(i1);
								var c2 = seq2.mSeq.charAt(i1);
								if(c1 != c2) {
									++score;
								}
							}
							var res = score;
							diff += res / (seq1.mSeq == null ? 0 : seq1.mSeq.length);
						}
					}
				}
			}
			var current = diff / comparisons;
			if(current < best) {
				best = current;
				a = spSA;
				b = spSB;
			}
		}
	}
	var l = new List();
	l.add(a);
	l.add(b);
	return l;
};
kretha_FourTimesRule.mergeSpecies = function(cladeA,cladeB,spA,spB,l) {
	var _g_head = cladeA.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var lA = val;
		if(lA == spA) {
			continue;
		}
		l.add(lA);
	}
	var _g_head1 = cladeB.h;
	while(_g_head1 != null) {
		var val1 = _g_head1.item;
		_g_head1 = _g_head1.next;
		var lB = val1;
		if(lB == spB) {
			continue;
		}
		l.add(lB);
	}
	var u = new List();
	var _g_head2 = spA.h;
	while(_g_head2 != null) {
		var val2 = _g_head2.item;
		_g_head2 = _g_head2.next;
		var n1 = val2;
		u.add(n1);
	}
	var _g_head3 = spB.h;
	while(_g_head3 != null) {
		var val3 = _g_head3.item;
		_g_head3 = _g_head3.next;
		var n2 = val3;
		u.add(n2);
	}
	l.add(u);
};
kretha_FourTimesRule.seqsInClade = function(c) {
	var l = new List();
	var _this = c.mConnectedInfo;
	var seq = __map_reserved["sequence"] != null ? _this.getReserved("sequence") : _this.h["sequence"];
	if(seq != null) {
		l.add(seq);
	}
	var _g_head = c.mChilds.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var subClade = val;
		var subL = kretha_FourTimesRule.seqsInClade(subClade);
		var _g_head1 = subL.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var s = val1;
			l.add(s);
		}
	}
	var _this1 = c.mConnectedInfo;
	if(__map_reserved["seqNames"] != null) {
		_this1.setReserved("seqNames",l);
	} else {
		_this1.h["seqNames"] = l;
	}
	return l;
};
kretha_FourTimesRule.floatToStringPrecision = function(n,prec) {
	n = Math.round(n * Math.pow(10,prec));
	var str = "" + n;
	var len = str.length;
	if(len <= prec) {
		while(len < prec) {
			str = "0" + str;
			++len;
		}
		return "0." + str;
	} else {
		return HxOverrides.substr(str,0,str.length - prec) + "." + HxOverrides.substr(str,str.length - prec,null);
	}
};
kretha_FourTimesRule.speciesInClade = function(c) {
	var l = new List();
	if(c.mChilds.length == 0) {
		var _this = c.mConnectedInfo;
		l.add(__map_reserved["seqNames"] != null ? _this.getReserved("seqNames") : _this.h["seqNames"]);
		var _this1 = c.mConnectedInfo;
		if(__map_reserved["species"] != null) {
			_this1.setReserved("species",l);
		} else {
			_this1.h["species"] = l;
		}
		return l;
	}
	var s = new List();
	var _g_head = c.mChilds.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var child = val;
		var sub = kretha_FourTimesRule.speciesInClade(child);
		s.add(sub);
	}
	if(s.length != 2) {
		throw new js__$Boot_HaxeError("WTF?");
	}
	var sA = s.first();
	var sB = s.last();
	var bestClades = kretha_FourTimesRule.getBestSubClades(sA,sB,c);
	var seqsA = bestClades.first();
	var seqsB = bestClades.last();
	var comparisons = 0;
	var diff = 0;
	var _g_head1 = seqsA.h;
	while(_g_head1 != null) {
		var val1 = _g_head1.item;
		_g_head1 = _g_head1.next;
		var seq1 = val1;
		var _g_head2 = seqsB.h;
		while(_g_head2 != null) {
			var val2 = _g_head2.item;
			_g_head2 = _g_head2.next;
			var seq2 = val2;
			var _g1 = 0;
			var _g = seq1.mNames.length;
			while(_g1 < _g) {
				var i = _g1++;
				var _g3 = 0;
				var _g2 = seq2.mNames.length;
				while(_g3 < _g2) {
					var j = _g3++;
					++comparisons;
					if((seq2.mSeq == null ? 0 : seq2.mSeq.length) != (seq1.mSeq == null ? 0 : seq1.mSeq.length)) {
						throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
					}
					var score = 0;
					var _g11 = 0;
					var _g4 = seq1.mSeq == null ? 0 : seq1.mSeq.length;
					while(_g11 < _g4) {
						var i1 = _g11++;
						var c1 = seq1.mSeq.charAt(i1);
						var c2 = seq2.mSeq.charAt(i1);
						if(c1 != c2) {
							++score;
						}
					}
					var res = score;
					diff += res / (seq1.mSeq == null ? 0 : seq1.mSeq.length);
				}
			}
		}
	}
	var k = diff / comparisons;
	var seqs = bestClades.first();
	var n = 0;
	var _g_head3 = seqs.h;
	while(_g_head3 != null) {
		var val3 = _g_head3.item;
		_g_head3 = _g_head3.next;
		var seq = val3;
		n += seq.mNames.length;
	}
	var count = 0;
	var diff1 = 0;
	var c3 = 0;
	var _g_head4 = seqs.h;
	while(_g_head4 != null) {
		var val4 = _g_head4.item;
		_g_head4 = _g_head4.next;
		var seq11 = val4;
		var _g12 = 0;
		var _g5 = seq11.mNames.length;
		while(_g12 < _g5) {
			var i2 = _g12++;
			var d = 0;
			var _g2_head = seqs.h;
			while(_g2_head != null) {
				var val5 = _g2_head.item;
				_g2_head = _g2_head.next;
				var seq21 = val5;
				var _g31 = 0;
				var _g21 = seq21.mNames.length;
				while(_g31 < _g21) {
					var j1 = _g31++;
					if(c3 == d) {
						++d;
						continue;
					}
					++count;
					if((seq21.mSeq == null ? 0 : seq21.mSeq.length) != (seq11.mSeq == null ? 0 : seq11.mSeq.length)) {
						throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
					}
					var score1 = 0;
					var _g13 = 0;
					var _g6 = seq11.mSeq == null ? 0 : seq11.mSeq.length;
					while(_g13 < _g6) {
						var i3 = _g13++;
						var c11 = seq11.mSeq.charAt(i3);
						var c21 = seq21.mSeq.charAt(i3);
						if(c11 != c21) {
							++score1;
						}
					}
					var res1 = score1;
					diff1 += res1 / (seq11.mSeq == null ? 0 : seq11.mSeq.length);
					++d;
				}
			}
			++c3;
		}
	}
	var pairwiseDistance = count == 0 ? 0 : diff1 / count;
	var pi = 0;
	if(pairwiseDistance == 0) {
		var _this2 = seqs.first();
		var seqLen = _this2.mSeq == null ? 0 : _this2.mSeq.length;
		pairwiseDistance = 1 / seqLen;
	}
	if(n == 1) {
		n = 2;
	}
	pi = pairwiseDistance * n / (n - 1);
	var theta1 = pi / (1 - 4 * pi / 3);
	var seqs1 = bestClades.last();
	var n1 = 0;
	var _g_head5 = seqs1.h;
	while(_g_head5 != null) {
		var val6 = _g_head5.item;
		_g_head5 = _g_head5.next;
		var seq3 = val6;
		n1 += seq3.mNames.length;
	}
	var count1 = 0;
	var diff2 = 0;
	var c4 = 0;
	var _g_head6 = seqs1.h;
	while(_g_head6 != null) {
		var val7 = _g_head6.item;
		_g_head6 = _g_head6.next;
		var seq12 = val7;
		var _g14 = 0;
		var _g7 = seq12.mNames.length;
		while(_g14 < _g7) {
			var i4 = _g14++;
			var d1 = 0;
			var _g2_head1 = seqs1.h;
			while(_g2_head1 != null) {
				var val8 = _g2_head1.item;
				_g2_head1 = _g2_head1.next;
				var seq22 = val8;
				var _g32 = 0;
				var _g22 = seq22.mNames.length;
				while(_g32 < _g22) {
					var j2 = _g32++;
					if(c4 == d1) {
						++d1;
						continue;
					}
					++count1;
					if((seq22.mSeq == null ? 0 : seq22.mSeq.length) != (seq12.mSeq == null ? 0 : seq12.mSeq.length)) {
						throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
					}
					var score2 = 0;
					var _g15 = 0;
					var _g8 = seq12.mSeq == null ? 0 : seq12.mSeq.length;
					while(_g15 < _g8) {
						var i5 = _g15++;
						var c12 = seq12.mSeq.charAt(i5);
						var c22 = seq22.mSeq.charAt(i5);
						if(c12 != c22) {
							++score2;
						}
					}
					var res2 = score2;
					diff2 += res2 / (seq12.mSeq == null ? 0 : seq12.mSeq.length);
					++d1;
				}
			}
			++c4;
		}
	}
	var pairwiseDistance1 = count1 == 0 ? 0 : diff2 / count1;
	var pi1 = 0;
	if(pairwiseDistance1 == 0) {
		var _this3 = seqs1.first();
		var seqLen1 = _this3.mSeq == null ? 0 : _this3.mSeq.length;
		pairwiseDistance1 = 1 / seqLen1;
	}
	if(n1 == 1) {
		n1 = 2;
	}
	pi1 = pairwiseDistance1 * n1 / (n1 - 1);
	var theta2 = pi1 / (1 - 4 * pi1 / 3);
	var info = kretha_FourTimesRule.floatToStringPrecision(theta1,3) + " " + kretha_FourTimesRule.floatToStringPrecision(theta2,3);
	c.mInfo.add(info);
	var theta = theta1 > theta2 ? theta1 : theta2;
	if(theta != -1) {
		var ratio = k / theta;
		var info1 = kretha_FourTimesRule.floatToStringPrecision(k,3) + "/" + kretha_FourTimesRule.floatToStringPrecision(theta,3) + "=" + kretha_FourTimesRule.floatToStringPrecision(ratio,3);
		c.mInfo.add(info1);
		if(ratio >= 4) {
			if(sA.length == 1 && sB.length == 1) {
				var colors_0 = "green";
				var colors_1 = "blue";
				var colors_2 = "red";
				var pcolor = 0;
				var _g_head7 = c.mChilds.h;
				while(_g_head7 != null) {
					var val9 = _g_head7.item;
					_g_head7 = _g_head7.next;
					var child1 = val9;
					pcolor = (pcolor + 1) % 3;
				}
			}
			var _g_head8 = sA.h;
			while(_g_head8 != null) {
				var val10 = _g_head8.item;
				_g_head8 = _g_head8.next;
				var n11 = val10;
				l.add(n11);
			}
			var _g_head9 = sB.h;
			while(_g_head9 != null) {
				var val11 = _g_head9.item;
				_g_head9 = _g_head9.next;
				var n2 = val11;
				l.add(n2);
			}
		} else {
			kretha_FourTimesRule.mergeSpecies(sA,sB,bestClades.first(),bestClades.last(),l);
		}
	} else {
		kretha_FourTimesRule.mergeSpecies(sA,sB,bestClades.first(),bestClades.last(),l);
	}
	return l;
};
kretha_FourTimesRule.doRule = function(c) {
	kretha_FourTimesRule.seqsInClade(c);
	kretha_FourTimesRule.speciesInClade(c);
};
var kretha_Graph = function(nodeInfo) {
	var this1 = new haxe_ds__$HashMap_HashMapData();
	this.mNodes = this1;
	if(nodeInfo != null) {
		var _g = 0;
		while(_g < nodeInfo.length) {
			var node = nodeInfo[_g];
			++_g;
			var gn = new kretha_GraphNode(node);
			var this2 = this.mNodes;
			var _this = this2.keys;
			var key = node.hashCode();
			_this.h[key] = node;
			var _this1 = this2.values;
			var key1 = node.hashCode();
			_this1.h[key1] = gn;
		}
	}
};
kretha_Graph.__name__ = true;
kretha_Graph.prototype = {
	addNode: function(ele) {
		var gn = new kretha_GraphNode(ele);
		var this1 = this.mNodes;
		var _this = this1.keys;
		var key = ele.hashCode();
		_this.h[key] = ele;
		var _this1 = this1.values;
		var key1 = ele.hashCode();
		_this1.h[key1] = gn;
	}
	,exists: function(ele) {
		var _this = this.mNodes.values;
		var key = ele.hashCode();
		return _this.h.hasOwnProperty(key);
	}
	,addEdge: function(x,y,val) {
		var _this = this.mNodes.values;
		var key = x.hashCode();
		var v1 = _this.h[key];
		if(v1 == null) {
			throw new js__$Boot_HaxeError(Std.string(x) + " not in graph!");
		}
		var _this1 = this.mNodes.values;
		var key1 = y.hashCode();
		var v2 = _this1.h[key1];
		if(v2 == null) {
			throw new js__$Boot_HaxeError(Std.string(y) + " not in graph!");
		}
		v1.addEdge(v2,val);
		v2.addEdge(v1,val);
	}
	,getEdges: function(x) {
		var _this = this.mNodes.values;
		var key = x.hashCode();
		var v1 = _this.h[key];
		if(v1 == null) {
			throw new js__$Boot_HaxeError(Std.string(x) + " not in graph!");
		}
		return v1.getEdges();
	}
	,getConnection: function(x,y) {
		var _this = this.mNodes.values;
		var key = x.hashCode();
		var v1 = _this.h[key];
		var _this1 = this.mNodes.values;
		var key1 = y.hashCode();
		var v2 = _this1.h[key1];
		return v1.getEdge(v2);
	}
	,getGraphDotRepresentation: function() {
		var result = new List();
		var this1 = new haxe_ds__$HashMap_HashMapData();
		var seen = this1;
		result.add("graph {");
		var node = this.mNodes.values.iterator();
		while(node.hasNext()) {
			var node1 = node.next();
			var ele = node1.mEleObject;
			var _g_head = node1.getEdges().h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var edge = val;
				var _this = seen.values;
				var key = edge.v.hashCode();
				if(_this.h.hasOwnProperty(key)) {
					continue;
				}
				result.add("  " + ele.getNodeName() + " -- " + edge.v.getNodeName() + " [label=\"" + Std.string(edge.e) + "\"];");
			}
			var _this1 = seen.keys;
			var key1 = ele.hashCode();
			_this1.h[key1] = ele;
			var _this2 = seen.values;
			var key2 = ele.hashCode();
			_this2.h[key2] = true;
		}
		result.add("}");
		return result.join("\n");
	}
	,__class__: kretha_Graph
};
var kretha_GraphNode = function(ele) {
	this.mEleObject = ele;
	this.mConnectedEdges = new List();
};
kretha_GraphNode.__name__ = true;
kretha_GraphNode.prototype = {
	getElement: function() {
		return this.mEleObject;
	}
	,addEdge: function(other,e) {
		var _g_head = this.mConnectedEdges.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var edge = val;
			if(edge.node == other) {
				edge.e = e;
				return;
			}
		}
		this.mConnectedEdges.add({ node : other, e : e});
	}
	,isConnectedTo: function(other) {
		var _g_head = this.mConnectedEdges.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var edge = val;
			if(edge.node == other) {
				return true;
			}
		}
		return false;
	}
	,getEdge: function(other) {
		var _g_head = this.mConnectedEdges.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var edge = val;
			if(edge.node == other) {
				return edge.e;
			}
		}
		return null;
	}
	,getEdges: function() {
		var result = new List();
		var _g_head = this.mConnectedEdges.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var edge = val;
			result.add({ v : edge.node.mEleObject, e : edge.e});
		}
		return result;
	}
	,__class__: kretha_GraphNode
};
var kretha_Kretha = function() { };
kretha_Kretha.__name__ = true;
kretha_Kretha.onMessage = function(e) {
	var fileContent = js_Boot.__cast(e.data.txt , String);
	var reader = new kretha_FastaAlignmentReader();
	var seqs = reader.readSequences(fileContent);
	var g = kretha_NeighborJoining.run(seqs);
	var c = kretha_MidPointRooter.root(g,seqs);
	kretha_FourTimesRule.doRule(c);
	var svg = c.getSVG();
	var result = new haxe_ds_StringMap();
	if(__map_reserved["svg"] != null) {
		result.setReserved("svg",svg);
	} else {
		result.h["svg"] = svg;
	}
	kretha_Kretha.workerScope.postMessage(result);
};
kretha_Kretha.main = function() {
	kretha_Kretha.workerScope = self;
	kretha_Kretha.workerScope.onmessage = kretha_Kretha.onMessage;
};
var kretha_MidPointRooter = function() { };
kretha_MidPointRooter.__name__ = true;
kretha_MidPointRooter.getLongestPath = function(g,current,commingFrom) {
	var bestLength = 0;
	var path = null;
	var _g_head;
	var _this = g.mNodes.values;
	var key = current.hashCode();
	var v1 = _this.h[key];
	if(v1 == null) {
		throw new js__$Boot_HaxeError(Std.string(current) + " not in graph!");
	}
	_g_head = v1.getEdges().h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var connection = val;
		if(connection.v == commingFrom) {
			continue;
		}
		var alternative = kretha_MidPointRooter.getLongestPath(g,connection.v,current);
		var l = alternative.l + connection.e;
		if(l > bestLength) {
			bestLength = l;
			path = alternative.path;
		}
	}
	if(path == null) {
		path = new List();
	}
	path.add(current);
	return { path : path, l : bestLength};
};
kretha_MidPointRooter.findLongestDistance = function(g,seqs) {
	var result = null;
	var _g = 0;
	while(_g < seqs.length) {
		var seq = seqs[_g];
		++_g;
		var alternativeResult = kretha_MidPointRooter.getLongestPath(g,seq,null);
		if(result == null || result.l < alternativeResult.l) {
			result = alternativeResult;
		}
	}
	return result;
};
kretha_MidPointRooter.findMidPoint = function(g,seqs) {
	var result = kretha_MidPointRooter.findLongestDistance(g,seqs);
	console.log("Longest path: " + Std.string(result.path) + " with length " + result.l);
	var midLen = result.l / 2;
	var sum = 0;
	var conLen = 0;
	var oldS = null;
	var newS = null;
	var _g_head = result.path.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var s = val;
		oldS = newS;
		newS = s;
		if(oldS == null) {
			continue;
		}
		var _this = g.mNodes.values;
		var key = newS.hashCode();
		var v1 = _this.h[key];
		var _this1 = g.mNodes.values;
		var key1 = oldS.hashCode();
		var v2 = _this1.h[key1];
		conLen = v1.getEdge(v2);
		sum += conLen;
		if(sum > midLen) {
			break;
		}
	}
	return { n1 : oldS, n2 : newS, a : conLen - (sum - midLen), b : sum - midLen};
};
kretha_MidPointRooter.root = function(g,seqs) {
	var midPoint = kretha_MidPointRooter.findMidPoint(g,seqs);
	console.log("midPoint: " + Std.string(midPoint));
	var rootClade = new kretha_Clade();
	rootClade.mInfo.add("Root");
	kretha_MidPointRooter.genSubClade(g,midPoint.n1,midPoint.n2,rootClade,midPoint.a,0);
	kretha_MidPointRooter.genSubClade(g,midPoint.n2,midPoint.n1,rootClade,midPoint.b,0);
	return rootClade;
};
kretha_MidPointRooter.genSubClade = function(g,process,commingFrom,parentClade,dist,lvl) {
	var _this = g.mNodes.values;
	var key = process.hashCode();
	var v1 = _this.h[key];
	if(v1 == null) {
		throw new js__$Boot_HaxeError(Std.string(process) + " not in graph!");
	}
	var connections = v1.getEdges();
	var clade = new kretha_Clade();
	var seq = process.mSeq;
	if(seq != null) {
		var _this1 = clade.mConnectedInfo;
		if(__map_reserved["sequence"] != null) {
			_this1.setReserved("sequence",process);
		} else {
			_this1.h["sequence"] = process;
		}
	}
	var result = null;
	if(process.mNames == null || process.mNames.length == 0) {
		result = "noName";
	} else if(process.mNames.length == 1) {
		result = process.mNames.first();
	} else {
		result = process.mNames.join(",");
	}
	clade.mInfo.add(result);
	clade.mParent = parentClade;
	clade.mDist = dist;
	parentClade.mChilds.add(clade);
	var _g_head;
	var _this2 = g.mNodes.values;
	var key1 = process.hashCode();
	var v11 = _this2.h[key1];
	if(v11 == null) {
		throw new js__$Boot_HaxeError(Std.string(process) + " not in graph!");
	}
	_g_head = v11.getEdges().h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var connection = val;
		if(connection.v == commingFrom) {
			continue;
		}
		kretha_MidPointRooter.genSubClade(g,connection.v,process,clade,connection.e,lvl + 1);
	}
};
var kretha_NeighborJoining = function() { };
kretha_NeighborJoining.__name__ = true;
kretha_NeighborJoining.run = function(seqs) {
	var length = seqs.length;
	var this1 = new Array(length);
	var r = this1;
	haxe_ds__$Vector_Vector_$Impl_$.blit(seqs,0,r,0,seqs.length);
	var endPoints = r;
	var nrIndividuals = seqs.length;
	var result = new kretha_Graph(endPoints);
	var d = new kretha_DistanceMatrix(endPoints);
	var _g = 0;
	while(_g < endPoints.length) {
		var ind1 = endPoints[_g];
		++_g;
		var _g1 = 0;
		while(_g1 < endPoints.length) {
			var ind2 = endPoints[_g1];
			++_g1;
			if(ind1 == ind2) {
				break;
			}
			if((ind2.mSeq == null ? 0 : ind2.mSeq.length) != (ind1.mSeq == null ? 0 : ind1.mSeq.length)) {
				throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
			}
			var score = 0;
			var _g11 = 0;
			var _g2 = ind1.mSeq == null ? 0 : ind1.mSeq.length;
			while(_g11 < _g2) {
				var i = _g11++;
				var c1 = ind1.mSeq.charAt(i);
				var c2 = ind2.mSeq.charAt(i);
				if(c1 != c2) {
					++score;
				}
			}
			var diff = score;
			if(ind1 == ind2) {
				if(diff != 0) {
					throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
				}
			}
			var _this = d.mNamePosLookup.values;
			var key = ind1.hashCode();
			var pos1 = _this.h[key];
			if(pos1 == null) {
				throw new js__$Boot_HaxeError(Std.string(ind1) + " not in map!");
			}
			var _this1 = d.mNamePosLookup.values;
			var key1 = ind2.hashCode();
			var pos2 = _this1.h[key1];
			if(pos2 == null) {
				throw new js__$Boot_HaxeError(Std.string(ind2) + " not in map!");
			}
			if(pos1 > pos2) {
				var swap = pos1;
				pos1 = pos2;
				pos2 = swap;
			}
			d.mValues[pos1 + pos2 * d.mWidth] = diff;
		}
	}
	var innerNumber = 0;
	while(endPoints.length > 2) {
		var this2 = new haxe_ds__$HashMap_HashMapData();
		var r1 = this2;
		var _g3 = 0;
		while(_g3 < endPoints.length) {
			var seq = endPoints[_g3];
			++_g3;
			var sum = 0;
			var _g12 = 0;
			while(_g12 < endPoints.length) {
				var otherSeq = endPoints[_g12];
				++_g12;
				var ret = 0;
				if(seq != otherSeq) {
					var _this2 = d.mNamePosLookup.values;
					var key2 = seq.hashCode();
					var pos11 = _this2.h[key2];
					if(pos11 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq) + " not in map!");
					}
					var _this3 = d.mNamePosLookup.values;
					var key3 = otherSeq.hashCode();
					var pos21 = _this3.h[key3];
					if(pos21 == null) {
						throw new js__$Boot_HaxeError(Std.string(otherSeq) + " not in map!");
					}
					if(pos11 > pos21) {
						var swap1 = pos11;
						pos11 = pos21;
						pos21 = swap1;
					}
					ret = d.mValues[pos11 + pos21 * d.mWidth];
				}
				sum += ret;
			}
			var v = sum / (endPoints.length - 2);
			var _this4 = r1.keys;
			var key4 = seq.hashCode();
			_this4.h[key4] = seq;
			var _this5 = r1.values;
			var key5 = seq.hashCode();
			_this5.h[key5] = v;
		}
		var m = new kretha_DistanceMatrix(endPoints);
		var _g4 = 0;
		while(_g4 < endPoints.length) {
			var seq1 = endPoints[_g4];
			++_g4;
			var _this6 = r1.values;
			var key6 = seq1.hashCode();
			var r_i = _this6.h[key6];
			var _g13 = 0;
			while(_g13 < endPoints.length) {
				var seq2 = endPoints[_g13];
				++_g13;
				if(seq1 == seq2) {
					break;
				}
				var _this7 = r1.values;
				var key7 = seq2.hashCode();
				var r_j = _this7.h[key7];
				var ret1 = 0;
				if(seq1 != seq2) {
					var _this8 = d.mNamePosLookup.values;
					var key8 = seq1.hashCode();
					var pos12 = _this8.h[key8];
					if(pos12 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq1) + " not in map!");
					}
					var _this9 = d.mNamePosLookup.values;
					var key9 = seq2.hashCode();
					var pos22 = _this9.h[key9];
					if(pos22 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq2) + " not in map!");
					}
					if(pos12 > pos22) {
						var swap2 = pos12;
						pos12 = pos22;
						pos22 = swap2;
					}
					ret1 = d.mValues[pos12 + pos22 * d.mWidth];
				}
				var val = ret1 - (r_i + r_j);
				if(seq1 == seq2) {
					if(val != 0) {
						throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
					}
				}
				var _this10 = m.mNamePosLookup.values;
				var key10 = seq1.hashCode();
				var pos13 = _this10.h[key10];
				if(pos13 == null) {
					throw new js__$Boot_HaxeError(Std.string(seq1) + " not in map!");
				}
				var _this11 = m.mNamePosLookup.values;
				var key11 = seq2.hashCode();
				var pos23 = _this11.h[key11];
				if(pos23 == null) {
					throw new js__$Boot_HaxeError(Std.string(seq2) + " not in map!");
				}
				if(pos13 > pos23) {
					var swap3 = pos13;
					pos13 = pos23;
					pos23 = swap3;
				}
				m.mValues[pos13 + pos23 * m.mWidth] = val;
			}
		}
		var lowestSeq1 = endPoints[0];
		var lowestSeq2 = endPoints[1];
		var ret2 = 0;
		if(lowestSeq1 != lowestSeq2) {
			var _this12 = m.mNamePosLookup.values;
			var key12 = lowestSeq1.hashCode();
			var pos14 = _this12.h[key12];
			if(pos14 == null) {
				throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in map!");
			}
			var _this13 = m.mNamePosLookup.values;
			var key13 = lowestSeq2.hashCode();
			var pos24 = _this13.h[key13];
			if(pos24 == null) {
				throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in map!");
			}
			if(pos14 > pos24) {
				var swap4 = pos14;
				pos14 = pos24;
				pos24 = swap4;
			}
			ret2 = m.mValues[pos14 + pos24 * m.mWidth];
		}
		var lowestVal = ret2;
		var _g5 = 0;
		while(_g5 < endPoints.length) {
			var seq11 = endPoints[_g5];
			++_g5;
			var _g14 = 0;
			while(_g14 < endPoints.length) {
				var seq21 = endPoints[_g14];
				++_g14;
				if(seq11 == seq21) {
					break;
				}
				var ret3 = 0;
				if(seq11 != seq21) {
					var _this14 = m.mNamePosLookup.values;
					var key14 = seq11.hashCode();
					var pos15 = _this14.h[key14];
					if(pos15 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq11) + " not in map!");
					}
					var _this15 = m.mNamePosLookup.values;
					var key15 = seq21.hashCode();
					var pos25 = _this15.h[key15];
					if(pos25 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq21) + " not in map!");
					}
					if(pos15 > pos25) {
						var swap5 = pos15;
						pos15 = pos25;
						pos25 = swap5;
					}
					ret3 = m.mValues[pos15 + pos25 * m.mWidth];
				}
				var currentVal = ret3;
				if(currentVal < lowestVal) {
					lowestSeq1 = seq11;
					lowestSeq2 = seq21;
					var ret4 = 0;
					if(lowestSeq1 != lowestSeq2) {
						var _this16 = m.mNamePosLookup.values;
						var key16 = lowestSeq1.hashCode();
						var pos16 = _this16.h[key16];
						if(pos16 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in map!");
						}
						var _this17 = m.mNamePosLookup.values;
						var key17 = lowestSeq2.hashCode();
						var pos26 = _this17.h[key17];
						if(pos26 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in map!");
						}
						if(pos16 > pos26) {
							var swap6 = pos16;
							pos16 = pos26;
							pos26 = swap6;
						}
						ret4 = m.mValues[pos16 + pos26 * m.mWidth];
					}
					lowestVal = ret4;
				}
			}
		}
		var l = new List();
		l.add("Inner" + innerNumber++);
		var inner = new kretha_Sequence(l,null);
		var ret5 = 0;
		if(lowestSeq1 != lowestSeq2) {
			var _this18 = d.mNamePosLookup.values;
			var key18 = lowestSeq1.hashCode();
			var pos17 = _this18.h[key18];
			if(pos17 == null) {
				throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in map!");
			}
			var _this19 = d.mNamePosLookup.values;
			var key19 = lowestSeq2.hashCode();
			var pos27 = _this19.h[key19];
			if(pos27 == null) {
				throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in map!");
			}
			if(pos17 > pos27) {
				var swap7 = pos17;
				pos17 = pos27;
				pos27 = swap7;
			}
			ret5 = d.mValues[pos17 + pos27 * d.mWidth];
		}
		var dist = ret5;
		var _this20 = r1.values;
		var key20 = lowestSeq1.hashCode();
		var v_iu = dist + _this20.h[key20];
		var _this21 = r1.values;
		var key21 = lowestSeq2.hashCode();
		var v_iu1 = (v_iu - _this21.h[key21]) / 2;
		var v_ju = dist - v_iu1;
		var gn = new kretha_GraphNode(inner);
		var this3 = result.mNodes;
		var _this22 = this3.keys;
		var key22 = inner.hashCode();
		_this22.h[key22] = inner;
		var _this23 = this3.values;
		var key23 = inner.hashCode();
		_this23.h[key23] = gn;
		var _this24 = result.mNodes.values;
		var key24 = lowestSeq1.hashCode();
		var v1 = _this24.h[key24];
		if(v1 == null) {
			throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in graph!");
		}
		var _this25 = result.mNodes.values;
		var key25 = inner.hashCode();
		var v2 = _this25.h[key25];
		if(v2 == null) {
			throw new js__$Boot_HaxeError(Std.string(inner) + " not in graph!");
		}
		v1.addEdge(v2,v_iu1);
		v2.addEdge(v1,v_iu1);
		var _this26 = result.mNodes.values;
		var key26 = lowestSeq2.hashCode();
		var v11 = _this26.h[key26];
		if(v11 == null) {
			throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in graph!");
		}
		var _this27 = result.mNodes.values;
		var key27 = inner.hashCode();
		var v21 = _this27.h[key27];
		if(v21 == null) {
			throw new js__$Boot_HaxeError(Std.string(inner) + " not in graph!");
		}
		v11.addEdge(v21,v_ju);
		v21.addEdge(v11,v_ju);
		var length1 = endPoints.length - 1;
		var this4 = new Array(length1);
		var endPoints_new = this4;
		var idx = 0;
		var _g6 = 0;
		while(_g6 < endPoints.length) {
			var seq3 = endPoints[_g6];
			++_g6;
			if(seq3 == lowestSeq1 || seq3 == lowestSeq2) {
				continue;
			}
			endPoints_new[idx++] = seq3;
		}
		endPoints_new[idx] = inner;
		var d_new = new kretha_DistanceMatrix(endPoints_new);
		var _g7 = 0;
		while(_g7 < endPoints_new.length) {
			var seq12 = endPoints_new[_g7];
			++_g7;
			var _g15 = 0;
			while(_g15 < endPoints_new.length) {
				var seq22 = endPoints_new[_g15];
				++_g15;
				if(seq12 == seq22) {
					break;
				}
				if(seq12 == inner || seq22 == inner) {
					var k = seq12 == inner ? seq22 : seq12;
					var ret6 = 0;
					if(lowestSeq1 != k) {
						var _this28 = d.mNamePosLookup.values;
						var key28 = lowestSeq1.hashCode();
						var pos18 = _this28.h[key28];
						if(pos18 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in map!");
						}
						var _this29 = d.mNamePosLookup.values;
						var key29 = k.hashCode();
						var pos28 = _this29.h[key29];
						if(pos28 == null) {
							throw new js__$Boot_HaxeError(Std.string(k) + " not in map!");
						}
						if(pos18 > pos28) {
							var swap8 = pos18;
							pos18 = pos28;
							pos28 = swap8;
						}
						ret6 = d.mValues[pos18 + pos28 * d.mWidth];
					}
					var ret7 = 0;
					if(lowestSeq2 != k) {
						var _this30 = d.mNamePosLookup.values;
						var key30 = lowestSeq2.hashCode();
						var pos19 = _this30.h[key30];
						if(pos19 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in map!");
						}
						var _this31 = d.mNamePosLookup.values;
						var key31 = k.hashCode();
						var pos29 = _this31.h[key31];
						if(pos29 == null) {
							throw new js__$Boot_HaxeError(Std.string(k) + " not in map!");
						}
						if(pos19 > pos29) {
							var swap9 = pos19;
							pos19 = pos29;
							pos29 = swap9;
						}
						ret7 = d.mValues[pos19 + pos29 * d.mWidth];
					}
					var ret8 = 0;
					if(lowestSeq1 != lowestSeq2) {
						var _this32 = d.mNamePosLookup.values;
						var key32 = lowestSeq1.hashCode();
						var pos110 = _this32.h[key32];
						if(pos110 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in map!");
						}
						var _this33 = d.mNamePosLookup.values;
						var key33 = lowestSeq2.hashCode();
						var pos210 = _this33.h[key33];
						if(pos210 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in map!");
						}
						if(pos110 > pos210) {
							var swap10 = pos110;
							pos110 = pos210;
							pos210 = swap10;
						}
						ret8 = d.mValues[pos110 + pos210 * d.mWidth];
					}
					var dist1 = (ret6 + ret7 - ret8) / 2;
					if(seq12 == seq22) {
						if(dist1 != 0) {
							throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
						}
					}
					var _this34 = d_new.mNamePosLookup.values;
					var key34 = seq12.hashCode();
					var pos111 = _this34.h[key34];
					if(pos111 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq12) + " not in map!");
					}
					var _this35 = d_new.mNamePosLookup.values;
					var key35 = seq22.hashCode();
					var pos211 = _this35.h[key35];
					if(pos211 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq22) + " not in map!");
					}
					if(pos111 > pos211) {
						var swap11 = pos111;
						pos111 = pos211;
						pos211 = swap11;
					}
					d_new.mValues[pos111 + pos211 * d_new.mWidth] = dist1;
				} else {
					var ret9 = 0;
					if(seq12 != seq22) {
						var _this36 = d.mNamePosLookup.values;
						var key36 = seq12.hashCode();
						var pos112 = _this36.h[key36];
						if(pos112 == null) {
							throw new js__$Boot_HaxeError(Std.string(seq12) + " not in map!");
						}
						var _this37 = d.mNamePosLookup.values;
						var key37 = seq22.hashCode();
						var pos212 = _this37.h[key37];
						if(pos212 == null) {
							throw new js__$Boot_HaxeError(Std.string(seq22) + " not in map!");
						}
						if(pos112 > pos212) {
							var swap12 = pos112;
							pos112 = pos212;
							pos212 = swap12;
						}
						ret9 = d.mValues[pos112 + pos212 * d.mWidth];
					}
					var dist2 = ret9;
					if(seq12 == seq22) {
						if(dist2 != 0) {
							throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
						}
					}
					var _this38 = d_new.mNamePosLookup.values;
					var key38 = seq12.hashCode();
					var pos113 = _this38.h[key38];
					if(pos113 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq12) + " not in map!");
					}
					var _this39 = d_new.mNamePosLookup.values;
					var key39 = seq22.hashCode();
					var pos213 = _this39.h[key39];
					if(pos213 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq22) + " not in map!");
					}
					if(pos113 > pos213) {
						var swap13 = pos113;
						pos113 = pos213;
						pos213 = swap13;
					}
					d_new.mValues[pos113 + pos213 * d_new.mWidth] = dist2;
				}
			}
		}
		endPoints = endPoints_new;
		d = d_new;
	}
	var x1 = endPoints[0];
	var x2 = endPoints[1];
	var ret10 = 0;
	if(x1 != x2) {
		var _this40 = d.mNamePosLookup.values;
		var key40 = x1.hashCode();
		var pos114 = _this40.h[key40];
		if(pos114 == null) {
			throw new js__$Boot_HaxeError(Std.string(x1) + " not in map!");
		}
		var _this41 = d.mNamePosLookup.values;
		var key41 = x2.hashCode();
		var pos214 = _this41.h[key41];
		if(pos214 == null) {
			throw new js__$Boot_HaxeError(Std.string(x2) + " not in map!");
		}
		if(pos114 > pos214) {
			var swap14 = pos114;
			pos114 = pos214;
			pos214 = swap14;
		}
		ret10 = d.mValues[pos114 + pos214 * d.mWidth];
	}
	var dist3 = ret10;
	var x = endPoints[0];
	var y = endPoints[1];
	var _this42 = result.mNodes.values;
	var key42 = x.hashCode();
	var v12 = _this42.h[key42];
	if(v12 == null) {
		throw new js__$Boot_HaxeError(Std.string(x) + " not in graph!");
	}
	var _this43 = result.mNodes.values;
	var key43 = y.hashCode();
	var v22 = _this43.h[key43];
	if(v22 == null) {
		throw new js__$Boot_HaxeError(Std.string(y) + " not in graph!");
	}
	v12.addEdge(v22,dist3);
	v22.addEdge(v12,dist3);
	return result;
};
var kretha_Sequence = function(names,seq) {
	this.mNames = names;
	this.mSeq = seq == null ? seq : seq.toUpperCase();
	this.mHashCode = kretha_Sequence.nextHashCode;
	kretha_Sequence.nextHashCode++;
};
kretha_Sequence.__name__ = true;
kretha_Sequence.prototype = {
	getNames: function() {
		return this.mNames;
	}
	,getSequenceString: function() {
		return this.mSeq;
	}
	,getLength: function() {
		if(this.mSeq == null) {
			return 0;
		} else {
			return this.mSeq.length;
		}
	}
	,getDifferenceScore: function(o) {
		if((o.mSeq == null ? 0 : o.mSeq.length) != (this.mSeq == null ? 0 : this.mSeq.length)) {
			throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
		}
		var score = 0;
		var _g1 = 0;
		var _g = this.mSeq == null ? 0 : this.mSeq.length;
		while(_g1 < _g) {
			var i = _g1++;
			var c1 = this.mSeq.charAt(i);
			var c2 = o.mSeq.charAt(i);
			if(c1 != c2) {
				++score;
			}
		}
		return score;
	}
	,getNodeName: function() {
		var result = null;
		if(this.mNames == null || this.mNames.length == 0) {
			result = "noName";
		} else if(this.mNames.length == 1) {
			result = this.mNames.first();
		} else {
			result = this.mNames.join(",");
		}
		return result;
	}
	,toString: function() {
		var result = null;
		if(this.mNames == null || this.mNames.length == 0) {
			result = "noName";
		} else if(this.mNames.length == 1) {
			result = this.mNames.first();
		} else {
			result = this.mNames.join(",");
		}
		return result;
	}
	,hashCode: function() {
		return this.mHashCode;
	}
	,__class__: kretha_Sequence
};
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var __map_reserved = {};
js_Boot.__toStr = ({ }).toString;
kretha_Sequence.nextHashCode = 0;
kretha_Kretha.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
