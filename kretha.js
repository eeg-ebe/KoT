// Generated by Haxe 3.4.4
(function ($global) { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var List = function() {
	this.length = 0;
};
List.__name__ = true;
List.prototype = {
	add: function(item) {
		var x = new _$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,first: function() {
		if(this.h == null) {
			return null;
		} else {
			return this.h.item;
		}
	}
	,last: function() {
		if(this.q == null) {
			return null;
		} else {
			return this.q.item;
		}
	}
	,toString: function() {
		var s_b = "";
		var first = true;
		var l = this.h;
		s_b += "{";
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += ", ";
			}
			s_b += Std.string(Std.string(l.item));
			l = l.next;
		}
		s_b += "}";
		return s_b;
	}
	,join: function(sep) {
		var s_b = "";
		var first = true;
		var l = this.h;
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += sep == null ? "null" : "" + sep;
			}
			s_b += Std.string(l.item);
			l = l.next;
		}
		return s_b;
	}
	,__class__: List
};
var _$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
_$List_ListNode.__name__ = true;
_$List_ListNode.prototype = {
	__class__: _$List_ListNode
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds__$HashMap_HashMapData = function() {
	this.keys = new haxe_ds_IntMap();
	this.values = new haxe_ds_IntMap();
};
haxe_ds__$HashMap_HashMapData.__name__ = true;
haxe_ds__$HashMap_HashMapData.prototype = {
	__class__: haxe_ds__$HashMap_HashMapData
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_ds__$Vector_Vector_$Impl_$ = {};
haxe_ds__$Vector_Vector_$Impl_$.__name__ = true;
haxe_ds__$Vector_Vector_$Impl_$.blit = function(src,srcPos,dest,destPos,len) {
	if(src == dest) {
		if(srcPos < destPos) {
			var i = srcPos + len;
			var j = destPos + len;
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var k = _g1++;
				--i;
				--j;
				src[j] = src[i];
			}
		} else if(srcPos > destPos) {
			var i1 = srcPos;
			var j1 = destPos;
			var _g11 = 0;
			var _g2 = len;
			while(_g11 < _g2) {
				var k1 = _g11++;
				src[j1] = src[i1];
				++i1;
				++j1;
			}
		}
	} else {
		var _g12 = 0;
		var _g3 = len;
		while(_g12 < _g3) {
			var i2 = _g12++;
			dest[destPos + i2] = src[srcPos + i2];
		}
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__cast = function(o,t) {
	if(js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new js__$Boot_HaxeError("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var kretha_Clade = function() {
	this.mDistStretch = 12000;
	this.mLineTextDist = 3;
	this.mBorder = 20;
	this.mLineWidth = 1;
	this.mTextSize = 14;
	this.mTextDist = 5;
	this.mCladeDist = 5;
	this.mColor = "black";
	this.mDist = 0;
	this.mChilds = new List();
	this.mInfo = new List();
	this.mConnectedInfo = new haxe_ds_StringMap();
};
kretha_Clade.__name__ = true;
kretha_Clade.prototype = {
	colorfy: function(color) {
		if(this.mColor != "black") {
			return;
		}
		this.mColor = color;
		var _g_head = this.mChilds.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var child = val;
			child.colorfy(color);
		}
	}
	,setParent: function(clade,dist) {
		this.mParent = clade;
		this.mDist = dist;
		clade.mChilds.add(this);
	}
	,getChilds: function() {
		return this.mChilds;
	}
	,addInfo: function(info) {
		this.mInfo.add(info);
	}
	,isTerminal: function() {
		return this.mChilds.length == 0;
	}
	,isRoot: function() {
		return this.mParent == null;
	}
	,calcSize: function(useCache) {
		if(useCache && this.mLastSizeCalc != null) {
			return this.mLastSizeCalc;
		}
		var w = 0;
		var h = 0;
		if(this.mChilds.length == 0) {
			var maxInfoLen = 0;
			var _g_head = this.mInfo.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var info = val;
				if(maxInfoLen > info.length) {
					maxInfoLen = maxInfoLen;
				} else {
					maxInfoLen = info.length;
				}
			}
			w = this.mDist * this.mDistStretch + this.mLineTextDist + maxInfoLen * this.mTextSize;
			if(this.mInfo.length == 0) {
				h = this.mCladeDist << 1;
			} else {
				h = this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 1);
			}
		} else {
			var _g_head1 = this.mChilds.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var child = val1;
				var childInfo = child.calcSize(useCache);
				if(w > childInfo.w) {
					w = w;
				} else {
					w = childInfo.w;
				}
				h += childInfo.h;
			}
			w += this.mDist * this.mDistStretch;
			h += this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 2);
		}
		this.mLastSizeCalc = { w : w, h : h};
		return this.mLastSizeCalc;
	}
	,getSVG: function() {
		var result = [];
		var w = 0;
		var h = 0;
		if(this.mChilds.length == 0) {
			var maxInfoLen = 0;
			var _g_head = this.mInfo.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var info = val;
				if(maxInfoLen > info.length) {
					maxInfoLen = maxInfoLen;
				} else {
					maxInfoLen = info.length;
				}
			}
			w = this.mDist * this.mDistStretch + this.mLineTextDist + maxInfoLen * this.mTextSize;
			if(this.mInfo.length == 0) {
				h = this.mCladeDist << 1;
			} else {
				h = this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 1);
			}
		} else {
			var _g_head1 = this.mChilds.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var child = val1;
				var childInfo = child.calcSize(false);
				if(w > childInfo.w) {
					w = w;
				} else {
					w = childInfo.w;
				}
				h += childInfo.h;
			}
			w += this.mDist * this.mDistStretch;
			h += this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 2);
		}
		this.mLastSizeCalc = { w : w, h : h};
		var dim = this.mLastSizeCalc;
		result.push("<svg id='resultTree' version='1.1' baseProfile='full' width='" + (2 * this.mBorder + 200 + dim.w) + "' height='" + (2 * this.mBorder + dim.h) + "' xmlns='http://www.w3.org/2000/svg'>");
		result.push("<g style='stroke:" + this.mColor + ";stroke-width:" + this.mLineWidth + "' font-family='Courier New' font-size='" + this.mTextSize + "'>");
		this.paint(result,this.mBorder,this.mBorder,this.mColor);
		result.push("</g>");
		result.push("</svg>");
		return result.join("");
	}
	,paint: function(result,x,y,color) {
		var resX = 0;
		var resY = 0;
		var finalY = 0;
		result.push("<g id='" + this.mInfo.first() + "' style='stroke:" + this.mColor + "'>");
		if(this.mChilds.length == 0) {
			var dim;
			if(this.mLastSizeCalc != null) {
				dim = this.mLastSizeCalc;
			} else {
				var w = 0;
				var h = 0;
				if(this.mChilds.length == 0) {
					var maxInfoLen = 0;
					var _g_head = this.mInfo.h;
					while(_g_head != null) {
						var val = _g_head.item;
						_g_head = _g_head.next;
						var info = val;
						if(maxInfoLen > info.length) {
							maxInfoLen = maxInfoLen;
						} else {
							maxInfoLen = info.length;
						}
					}
					w = this.mDist * this.mDistStretch + this.mLineTextDist + maxInfoLen * this.mTextSize;
					if(this.mInfo.length == 0) {
						h = this.mCladeDist << 1;
					} else {
						h = this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 1);
					}
				} else {
					var _g_head1 = this.mChilds.h;
					while(_g_head1 != null) {
						var val1 = _g_head1.item;
						_g_head1 = _g_head1.next;
						var child = val1;
						var childInfo = child.calcSize(true);
						if(w > childInfo.w) {
							w = w;
						} else {
							w = childInfo.w;
						}
						h += childInfo.h;
					}
					w += this.mDist * this.mDistStretch;
					h += this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 2);
				}
				this.mLastSizeCalc = { w : w, h : h};
				dim = this.mLastSizeCalc;
			}
			finalY = dim.h + y;
			var mx = x;
			var my = y + dim.h / 2;
			result.push("<line x1='" + mx + "' y1='" + my + "' x2='" + (mx + this.mDist * this.mDistStretch) + "' y2='" + my + "' title='" + this.mDist + "'/>");
			resX = mx;
			resY = my;
			mx = x + this.mDist * this.mDistStretch + this.mLineTextDist;
			my = y + this.mCladeDist + this.mTextSize / 2 + 2.5;
			var _g_head2 = this.mInfo.h;
			while(_g_head2 != null) {
				var val2 = _g_head2.item;
				_g_head2 = _g_head2.next;
				var info1 = val2;
				result.push("<text x='" + mx + "' y='" + my + "'>" + info1 + "</text>");
				my += this.mTextSize + this.mTextDist;
			}
		} else {
			var dim1;
			if(this.mLastSizeCalc != null) {
				dim1 = this.mLastSizeCalc;
			} else {
				var w1 = 0;
				var h1 = 0;
				if(this.mChilds.length == 0) {
					var maxInfoLen1 = 0;
					var _g_head3 = this.mInfo.h;
					while(_g_head3 != null) {
						var val3 = _g_head3.item;
						_g_head3 = _g_head3.next;
						var info2 = val3;
						if(maxInfoLen1 > info2.length) {
							maxInfoLen1 = maxInfoLen1;
						} else {
							maxInfoLen1 = info2.length;
						}
					}
					w1 = this.mDist * this.mDistStretch + this.mLineTextDist + maxInfoLen1 * this.mTextSize;
					if(this.mInfo.length == 0) {
						h1 = this.mCladeDist << 1;
					} else {
						h1 = this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 1);
					}
				} else {
					var _g_head4 = this.mChilds.h;
					while(_g_head4 != null) {
						var val4 = _g_head4.item;
						_g_head4 = _g_head4.next;
						var child1 = val4;
						var childInfo1 = child1.calcSize(true);
						if(w1 > childInfo1.w) {
							w1 = w1;
						} else {
							w1 = childInfo1.w;
						}
						h1 += childInfo1.h;
					}
					w1 += this.mDist * this.mDistStretch;
					h1 += this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist + (this.mCladeDist << 2);
				}
				this.mLastSizeCalc = { w : w1, h : h1};
				dim1 = this.mLastSizeCalc;
			}
			finalY = dim1.h + y;
			var mx1 = x;
			var my1 = y + dim1.h / 2;
			result.push("<line x1='" + mx1 + "' y1='" + my1 + "' x2='" + (mx1 + this.mDist * this.mDistStretch) + "' y2='" + my1 + "' title='" + this.mDist + "'/>");
			resX = mx1;
			resY = my1;
			var h2 = this.mCladeDist;
			var lowestY = -1;
			var highestY = -1;
			var txtY = -1;
			var _g_head5 = this.mChilds.h;
			while(_g_head5 != null) {
				var val5 = _g_head5.item;
				_g_head5 = _g_head5.next;
				var child2 = val5;
				var childDim;
				if(child2.mLastSizeCalc != null) {
					childDim = child2.mLastSizeCalc;
				} else {
					var w2 = 0;
					var h3 = 0;
					if(child2.mChilds.length == 0) {
						var maxInfoLen2 = 0;
						var _g_head6 = child2.mInfo.h;
						while(_g_head6 != null) {
							var val6 = _g_head6.item;
							_g_head6 = _g_head6.next;
							var info3 = val6;
							if(maxInfoLen2 > info3.length) {
								maxInfoLen2 = maxInfoLen2;
							} else {
								maxInfoLen2 = info3.length;
							}
						}
						w2 = child2.mDist * child2.mDistStretch + child2.mLineTextDist + maxInfoLen2 * child2.mTextSize;
						if(child2.mInfo.length == 0) {
							h3 = child2.mCladeDist << 1;
						} else {
							h3 = child2.mInfo.length * child2.mTextSize + (child2.mInfo.length - 1) * child2.mTextDist + (child2.mCladeDist << 1);
						}
					} else {
						var _g_head7 = child2.mChilds.h;
						while(_g_head7 != null) {
							var val7 = _g_head7.item;
							_g_head7 = _g_head7.next;
							var child3 = val7;
							var childInfo2 = child3.calcSize(true);
							if(w2 > childInfo2.w) {
								w2 = w2;
							} else {
								w2 = childInfo2.w;
							}
							h3 += childInfo2.h;
						}
						w2 += child2.mDist * child2.mDistStretch;
						h3 += child2.mInfo.length * child2.mTextSize + (child2.mInfo.length - 1) * child2.mTextDist + (child2.mCladeDist << 2);
					}
					child2.mLastSizeCalc = { w : w2, h : h3};
					childDim = child2.mLastSizeCalc;
				}
				var midPoint = child2.paint(result,x + this.mDist * this.mDistStretch,y + h2,this.mColor);
				if(txtY != -1) {
					txtY = txtY;
				} else {
					txtY = midPoint.finalY;
				}
				if(lowestY != -1 && lowestY < midPoint.y) {
					lowestY = lowestY;
				} else {
					lowestY = midPoint.y;
				}
				if(highestY > midPoint.y) {
					highestY = highestY;
				} else {
					highestY = midPoint.y;
				}
				h2 += childDim.h + this.mInfo.length * this.mTextSize + (this.mInfo.length - 1) * this.mTextDist;
			}
			mx1 += this.mDist * this.mDistStretch;
			result.push("<line x1='" + mx1 + "' y1='" + lowestY + "' x2='" + mx1 + "' y2='" + highestY + "' title='" + this.mDist + "'/>");
			mx1 += this.mLineTextDist;
			my1 = txtY + this.mCladeDist + this.mTextSize / 2 + 2.5;
			var _g_head8 = this.mInfo.h;
			while(_g_head8 != null) {
				var val8 = _g_head8.item;
				_g_head8 = _g_head8.next;
				var info4 = val8;
				result.push("<text x='" + mx1 + "' y='" + my1 + "'>" + info4 + "</text>");
				my1 += this.mTextSize + this.mTextDist;
			}
		}
		result.push("</g>");
		return { x : resX, y : resY, finalY : finalY};
	}
	,getTextRepresentation: function(result,indent) {
		var _g1 = 0;
		var _g = indent;
		while(_g1 < _g) {
			var i = _g1++;
			result.push("  ");
		}
		result.push("Clade(" + this.mDist + ", " + this.mColor + ";" + Std.string(this.mInfo) + ")\n");
		var _g_head = this.mChilds.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var clade = val;
			clade.getTextRepresentation(result,indent + 1);
		}
	}
	,toString: function() {
		var result = [];
		this.getTextRepresentation(result,0);
		return result.join("");
	}
	,toString_: function() {
		var result = [];
		result.push("Clade(" + this.mInfo.join(",") + ")");
		result.push("  parent: " + (this.mParent == null ? "null" : this.mParent.mInfo.join(",")));
		result.push("  childs: " + this.mChilds.length);
		return result.join("");
	}
	,__class__: kretha_Clade
};
var kretha_CladeColorer = function() { };
kretha_CladeColorer.__name__ = true;
kretha_CladeColorer.getColor = function(i) {
	var ii = i % kretha_CladeColorer.colors.length;
	return kretha_CladeColorer.colors[ii];
};
kretha_CladeColorer.colorClade = function(c,i) {
	var ii = i % kretha_CladeColorer.colors.length;
	var color = kretha_CladeColorer.colors[ii];
	c.colorfy(color);
};
kretha_CladeColorer.findClade = function(c,l) {
	var tmp;
	var _this = c.mConnectedInfo;
	if((__map_reserved["psppl"] != null ? _this.getReserved("psppl") : _this.h["psppl"]) != l) {
		var _this1 = c.mConnectedInfo;
		tmp = (__map_reserved["seqNames"] != null ? _this1.getReserved("seqNames") : _this1.h["seqNames"]) == l;
	} else {
		tmp = true;
	}
	if(tmp) {
		return c;
	}
	var _g_head = c.mChilds.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var child = val;
		var ccc = kretha_CladeColorer.findClade(child,l);
		if(ccc != null) {
			return ccc;
		}
	}
	return null;
};
kretha_CladeColorer.colorClades = function(c,l) {
	var i = 0;
	var _g_head = l.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var ll = val;
		console.log("=== " + Std.string(ll));
		var cc = kretha_CladeColorer.findClade(c,ll);
		if(cc != null) {
			console.log(cc);
			var ii = i++ % kretha_CladeColorer.colors.length;
			var color = kretha_CladeColorer.colors[ii];
			cc.colorfy(color);
		}
	}
};
var kretha_Matrix = function(w,h) {
	if(w < 1) {
		throw new js__$Boot_HaxeError("Width must be bigger then 0!");
	}
	if(h < 1) {
		throw new js__$Boot_HaxeError("Height must be bigger then 0!");
	}
	this.mWidth = w;
	this.mHeight = h;
	var this1 = new Array(w * h);
	this.mValues = this1;
};
kretha_Matrix.__name__ = true;
kretha_Matrix.prototype = {
	getWidth: function() {
		return this.mWidth;
	}
	,getHeight: function() {
		return this.mHeight;
	}
	,getValue: function(x,y) {
		if(0 > x || x >= this.mWidth || 0 > y || y >= this.mHeight) {
			throw new js__$Boot_HaxeError("x or y (" + x + "," + y + ") out of range!");
		}
		return this.mValues[x + y * this.mWidth];
	}
	,setValue: function(x,y,val) {
		if(0 > x || x >= this.mWidth || 0 > y || y >= this.mHeight) {
			throw new js__$Boot_HaxeError("x or y (" + x + "," + y + ") out of range!");
		}
		this.mValues[x + y * this.mWidth] = val;
	}
	,toString: function() {
		var result = [];
		result.push("Matrix(" + this.mWidth + "," + this.mHeight + ")\n");
		var _g1 = 0;
		var _g = this.mHeight;
		while(_g1 < _g) {
			var j = _g1++;
			var _g3 = 0;
			var _g2 = this.mWidth;
			while(_g3 < _g2) {
				var i = _g3++;
				if(i != 0) {
					result.push("\t");
				}
				if(0 > i || i >= this.mWidth || 0 > j || j >= this.mHeight) {
					throw new js__$Boot_HaxeError("x or y (" + i + "," + j + ") out of range!");
				}
				result.push("" + this.mValues[i + j * this.mWidth]);
			}
			result.push("\n");
		}
		return result.join("");
	}
	,__class__: kretha_Matrix
};
var kretha_DistanceMatrix = function(names) {
	if(names == null || names.length == 0) {
		throw new js__$Boot_HaxeError("Names must not be empty!");
	}
	kretha_Matrix.call(this,names.length,names.length);
	this.mNames = names;
	var this1 = new haxe_ds__$HashMap_HashMapData();
	this.mNamePosLookup = this1;
	var pos = 0;
	var _g = 0;
	while(_g < names.length) {
		var name = names[_g];
		++_g;
		var this2 = this.mNamePosLookup;
		var _this = this2.keys;
		var key = name.hashCode();
		_this.h[key] = name;
		var _this1 = this2.values;
		var key1 = name.hashCode();
		_this1.h[key1] = pos++;
	}
};
kretha_DistanceMatrix.__name__ = true;
kretha_DistanceMatrix.__super__ = kretha_Matrix;
kretha_DistanceMatrix.prototype = $extend(kretha_Matrix.prototype,{
	getNames: function() {
		return this.mNames;
	}
	,lookup: function(x1,x2) {
		var ret = 0;
		if(x1 != x2) {
			var _this = this.mNamePosLookup.values;
			var key = x1.hashCode();
			var pos1 = _this.h[key];
			if(pos1 == null) {
				throw new js__$Boot_HaxeError(Std.string(x1) + " not in map!");
			}
			var _this1 = this.mNamePosLookup.values;
			var key1 = x2.hashCode();
			var pos2 = _this1.h[key1];
			if(pos2 == null) {
				throw new js__$Boot_HaxeError(Std.string(x2) + " not in map!");
			}
			if(pos1 > pos2) {
				var swap = pos1;
				pos1 = pos2;
				pos2 = swap;
			}
			ret = this.mValues[pos1 + pos2 * this.mWidth];
		}
		return ret;
	}
	,set: function(x1,x2,d) {
		if(x1 == x2) {
			if(d != 0) {
				throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
			}
		}
		var _this = this.mNamePosLookup.values;
		var key = x1.hashCode();
		var pos1 = _this.h[key];
		if(pos1 == null) {
			throw new js__$Boot_HaxeError(Std.string(x1) + " not in map!");
		}
		var _this1 = this.mNamePosLookup.values;
		var key1 = x2.hashCode();
		var pos2 = _this1.h[key1];
		if(pos2 == null) {
			throw new js__$Boot_HaxeError(Std.string(x2) + " not in map!");
		}
		if(pos1 > pos2) {
			var swap = pos1;
			pos1 = pos2;
			pos2 = swap;
		}
		this.mValues[pos1 + pos2 * this.mWidth] = d;
	}
	,toString: function() {
		var result = [];
		result.push("Dist");
		var _g = 0;
		var _g1 = this.mNames;
		while(_g < _g1.length) {
			var name = _g1[_g];
			++_g;
			result.push("\t" + Std.string(name));
		}
		result.push("\n");
		var x = 0;
		var _g2 = 0;
		var _g11 = this.mNames;
		while(_g2 < _g11.length) {
			var name1 = _g11[_g2];
			++_g2;
			result.push(Std.string(name1));
			var y = 0;
			var _g21 = 0;
			var _g3 = this.mNames;
			while(_g21 < _g3.length) {
				var name2 = _g3[_g21];
				++_g21;
				if(y >= x) {
					break;
				}
				result.push("\t" + this.mValues[y + x * this.mWidth]);
				++y;
			}
			result.push("\n");
			++x;
		}
		return result.join("");
	}
	,__class__: kretha_DistanceMatrix
});
var kretha_DistanceMatrixReader = function() {
};
kretha_DistanceMatrixReader.__name__ = true;
kretha_DistanceMatrixReader.prototype = {
	readMatrix: function(fileContent) {
		var lines = fileContent.split("\n");
		var names = new List();
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			line = StringTools.trim(line);
			if(line == "" || line.charAt(0) == "#") {
				continue;
			}
			var name = line.split("\t")[0];
			names.add(name);
		}
		var length = names.length;
		var this1 = new Array(length);
		var seqs = this1;
		var lookup = new haxe_ds_StringMap();
		var i = 0;
		var _g_head = names.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var name1 = val;
			var n = new List();
			n.add(name1);
			var s = new kretha_Sequence(n,"");
			seqs[i++] = s;
			if(__map_reserved[name1] != null) {
				lookup.setReserved(name1,s);
			} else {
				lookup.h[name1] = s;
			}
		}
		var d = new kretha_DistanceMatrix(seqs);
		var _g1 = 0;
		while(_g1 < lines.length) {
			var line1 = lines[_g1];
			++_g1;
			line1 = StringTools.trim(line1);
			if(line1 == "" || line1.charAt(0) == "#") {
				continue;
			}
			var name2 = line1.split("\t")[0];
			var s1 = __map_reserved[name2] != null ? lookup.getReserved(name2) : lookup.h[name2];
			var pos = -2;
			var _g11 = 0;
			var _g2 = line1.split("\t");
			while(_g11 < _g2.length) {
				var e = _g2[_g11];
				++_g11;
				++pos;
				if(pos == -1) {
					continue;
				}
				var s2 = seqs[pos];
				var val1 = parseFloat(e);
				if(s1 == s2) {
					if(val1 != 0) {
						throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
					}
				}
				var _this = d.mNamePosLookup.values;
				var key = s1.hashCode();
				var pos1 = _this.h[key];
				if(pos1 == null) {
					throw new js__$Boot_HaxeError(Std.string(s1) + " not in map!");
				}
				var _this1 = d.mNamePosLookup.values;
				var key1 = s2.hashCode();
				var pos2 = _this1.h[key1];
				if(pos2 == null) {
					throw new js__$Boot_HaxeError(Std.string(s2) + " not in map!");
				}
				if(pos1 > pos2) {
					var swap = pos1;
					pos1 = pos2;
					pos2 = swap;
				}
				d.mValues[pos1 + pos2 * d.mWidth] = val1;
			}
		}
		console.log(d);
		return d;
	}
	,__class__: kretha_DistanceMatrixReader
};
var kretha_IAlignmentReader = function() { };
kretha_IAlignmentReader.__name__ = true;
kretha_IAlignmentReader.prototype = {
	__class__: kretha_IAlignmentReader
};
var kretha_FastaAlignmentReader = function() {
};
kretha_FastaAlignmentReader.__name__ = true;
kretha_FastaAlignmentReader.__interfaces__ = [kretha_IAlignmentReader];
kretha_FastaAlignmentReader.prototype = {
	readSequences: function(fileContent) {
		var sequences = [];
		var lines = fileContent.split("\n");
		var name = null;
		var seq = null;
		var seqAlreadySeen = new haxe_ds_StringMap();
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			line = StringTools.trim(line);
			if(line == "" || line.charAt(0) == ";" || line.charAt(0) == "#") {
				continue;
			}
			if(line.charAt(0) == ">") {
				if(name != null) {
					if(__map_reserved[seq] != null ? seqAlreadySeen.existsReserved(seq) : seqAlreadySeen.h.hasOwnProperty(seq)) {
						var s = __map_reserved[seq] != null ? seqAlreadySeen.getReserved(seq) : seqAlreadySeen.h[seq];
						s.mNames.add(name);
					} else {
						var l = new List();
						l.add(name);
						var s1 = new kretha_Sequence(l,seq);
						if(__map_reserved[seq] != null) {
							seqAlreadySeen.setReserved(seq,s1);
						} else {
							seqAlreadySeen.h[seq] = s1;
						}
						sequences.push(s1);
					}
				}
				name = StringTools.trim(HxOverrides.substr(line,1,null));
				seq = "";
			} else {
				seq = seq.toUpperCase() + line;
			}
		}
		if(name != null) {
			if(__map_reserved[seq] != null ? seqAlreadySeen.existsReserved(seq) : seqAlreadySeen.h.hasOwnProperty(seq)) {
				var s2 = __map_reserved[seq] != null ? seqAlreadySeen.getReserved(seq) : seqAlreadySeen.h[seq];
				s2.mNames.add(name);
			} else {
				var l1 = new List();
				l1.add(name);
				var s3 = new kretha_Sequence(l1,seq);
				if(__map_reserved[seq] != null) {
					seqAlreadySeen.setReserved(seq,s3);
				} else {
					seqAlreadySeen.h[seq] = s3;
				}
				sequences.push(s3);
			}
		}
		var length = sequences.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g1 = 0;
		while(_g1 < sequences.length) {
			var sequence = sequences[_g1];
			++_g1;
			result[i++] = sequence;
		}
		return result;
	}
	,__class__: kretha_FastaAlignmentReader
};
var kretha_FourTimesRule = function() { };
kretha_FourTimesRule.__name__ = true;
kretha_FourTimesRule.calcPairwiseDifference = function(a1,a2) {
	var result = 0;
	if(kretha_FourTimesRule.distanceMatrix != null) {
		var _this = kretha_FourTimesRule.distanceMatrix;
		var ret = 0;
		if(a1 != a2) {
			var _this1 = _this.mNamePosLookup.values;
			var key = a1.hashCode();
			var pos1 = _this1.h[key];
			if(pos1 == null) {
				throw new js__$Boot_HaxeError(Std.string(a1) + " not in map!");
			}
			var _this2 = _this.mNamePosLookup.values;
			var key1 = a2.hashCode();
			var pos2 = _this2.h[key1];
			if(pos2 == null) {
				throw new js__$Boot_HaxeError(Std.string(a2) + " not in map!");
			}
			if(pos1 > pos2) {
				var swap = pos1;
				pos1 = pos2;
				pos2 = swap;
			}
			ret = _this.mValues[pos1 + pos2 * _this.mWidth];
		}
		result = ret;
	} else {
		if((a2.mSeq == null ? 0 : a2.mSeq.length) != (a1.mSeq == null ? 0 : a1.mSeq.length)) {
			throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
		}
		var score = 0;
		var count = 0;
		var _g1 = 0;
		var _g = a1.mSeq == null ? 0 : a1.mSeq.length;
		while(_g1 < _g) {
			var i = _g1++;
			var c1 = a1.mSeq.charAt(i);
			var c2 = a2.mSeq.charAt(i);
			if(!(c1 == "-" || c1 == "A" || c1 == "T" || c1 == "G" || c1 == "C") || !(c2 == "-" || c2 == "A" || c2 == "T" || c2 == "G" || c2 == "C")) {
				continue;
			}
			if(c1 != c2) {
				++score;
			}
			++count;
		}
		var res = count == 0 ? 1.0 : score / count;
		result = res;
	}
	return result;
};
kretha_FourTimesRule.calcPairwiseDistance = function(seqs) {
	var count = 0;
	var diff = 0;
	var c = 0;
	var _g_head = seqs.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var seq1 = val;
		var _g1 = 0;
		var _g = seq1.mNames.length;
		while(_g1 < _g) {
			var i = _g1++;
			var d = 0;
			var _g2_head = seqs.h;
			while(_g2_head != null) {
				var val1 = _g2_head.item;
				_g2_head = _g2_head.next;
				var seq2 = val1;
				var _g3 = 0;
				var _g2 = seq2.mNames.length;
				while(_g3 < _g2) {
					var j = _g3++;
					if(c == d) {
						++d;
						continue;
					}
					++count;
					var result = 0;
					if(kretha_FourTimesRule.distanceMatrix != null) {
						var _this = kretha_FourTimesRule.distanceMatrix;
						var ret = 0;
						if(seq1 != seq2) {
							var _this1 = _this.mNamePosLookup.values;
							var key = seq1.hashCode();
							var pos1 = _this1.h[key];
							if(pos1 == null) {
								throw new js__$Boot_HaxeError(Std.string(seq1) + " not in map!");
							}
							var _this2 = _this.mNamePosLookup.values;
							var key1 = seq2.hashCode();
							var pos2 = _this2.h[key1];
							if(pos2 == null) {
								throw new js__$Boot_HaxeError(Std.string(seq2) + " not in map!");
							}
							if(pos1 > pos2) {
								var swap = pos1;
								pos1 = pos2;
								pos2 = swap;
							}
							ret = _this.mValues[pos1 + pos2 * _this.mWidth];
						}
						result = ret;
					} else {
						if((seq2.mSeq == null ? 0 : seq2.mSeq.length) != (seq1.mSeq == null ? 0 : seq1.mSeq.length)) {
							throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
						}
						var score = 0;
						var count1 = 0;
						var _g11 = 0;
						var _g4 = seq1.mSeq == null ? 0 : seq1.mSeq.length;
						while(_g11 < _g4) {
							var i1 = _g11++;
							var c1 = seq1.mSeq.charAt(i1);
							var c2 = seq2.mSeq.charAt(i1);
							if(!(c1 == "-" || c1 == "A" || c1 == "T" || c1 == "G" || c1 == "C") || !(c2 == "-" || c2 == "A" || c2 == "T" || c2 == "G" || c2 == "C")) {
								continue;
							}
							if(c1 != c2) {
								++score;
							}
							++count1;
						}
						var res = count1 == 0 ? 1.0 : score / count1;
						result = res;
					}
					diff += result;
					++d;
				}
			}
			++c;
		}
	}
	if(count == 0) {
		return 0;
	}
	return diff / count;
};
kretha_FourTimesRule.calcPairwiseDistanceOfSubClades = function(seqsA,seqsB) {
	var comparisons = 0;
	var diff = 0;
	var _g_head = seqsA.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var seq1 = val;
		var _g_head1 = seqsB.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var seq2 = val1;
			var _g1 = 0;
			var _g = seq1.mNames.length;
			while(_g1 < _g) {
				var i = _g1++;
				var _g3 = 0;
				var _g2 = seq2.mNames.length;
				while(_g3 < _g2) {
					var j = _g3++;
					++comparisons;
					var result = 0;
					if(kretha_FourTimesRule.distanceMatrix != null) {
						var _this = kretha_FourTimesRule.distanceMatrix;
						var ret = 0;
						if(seq1 != seq2) {
							var _this1 = _this.mNamePosLookup.values;
							var key = seq1.hashCode();
							var pos1 = _this1.h[key];
							if(pos1 == null) {
								throw new js__$Boot_HaxeError(Std.string(seq1) + " not in map!");
							}
							var _this2 = _this.mNamePosLookup.values;
							var key1 = seq2.hashCode();
							var pos2 = _this2.h[key1];
							if(pos2 == null) {
								throw new js__$Boot_HaxeError(Std.string(seq2) + " not in map!");
							}
							if(pos1 > pos2) {
								var swap = pos1;
								pos1 = pos2;
								pos2 = swap;
							}
							ret = _this.mValues[pos1 + pos2 * _this.mWidth];
						}
						result = ret;
					} else {
						if((seq2.mSeq == null ? 0 : seq2.mSeq.length) != (seq1.mSeq == null ? 0 : seq1.mSeq.length)) {
							throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
						}
						var score = 0;
						var count = 0;
						var _g11 = 0;
						var _g4 = seq1.mSeq == null ? 0 : seq1.mSeq.length;
						while(_g11 < _g4) {
							var i1 = _g11++;
							var c1 = seq1.mSeq.charAt(i1);
							var c2 = seq2.mSeq.charAt(i1);
							if(!(c1 == "-" || c1 == "A" || c1 == "T" || c1 == "G" || c1 == "C") || !(c2 == "-" || c2 == "A" || c2 == "T" || c2 == "G" || c2 == "C")) {
								continue;
							}
							if(c1 != c2) {
								++score;
							}
							++count;
						}
						var res = count == 0 ? 1.0 : score / count;
						result = res;
					}
					diff += result;
				}
			}
		}
	}
	return diff / comparisons;
};
kretha_FourTimesRule.calcTheta = function(seqs,c) {
	var n = 0;
	var _g_head = seqs.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var seq = val;
		n += seq.mNames.length;
	}
	var count = 0;
	var diff = 0;
	var c1 = 0;
	var _g_head1 = seqs.h;
	while(_g_head1 != null) {
		var val1 = _g_head1.item;
		_g_head1 = _g_head1.next;
		var seq1 = val1;
		var _g1 = 0;
		var _g = seq1.mNames.length;
		while(_g1 < _g) {
			var i = _g1++;
			var d = 0;
			var _g2_head = seqs.h;
			while(_g2_head != null) {
				var val2 = _g2_head.item;
				_g2_head = _g2_head.next;
				var seq2 = val2;
				var _g3 = 0;
				var _g2 = seq2.mNames.length;
				while(_g3 < _g2) {
					var j = _g3++;
					if(c1 == d) {
						++d;
						continue;
					}
					++count;
					var result = 0;
					if(kretha_FourTimesRule.distanceMatrix != null) {
						var _this = kretha_FourTimesRule.distanceMatrix;
						var ret = 0;
						if(seq1 != seq2) {
							var _this1 = _this.mNamePosLookup.values;
							var key = seq1.hashCode();
							var pos1 = _this1.h[key];
							if(pos1 == null) {
								throw new js__$Boot_HaxeError(Std.string(seq1) + " not in map!");
							}
							var _this2 = _this.mNamePosLookup.values;
							var key1 = seq2.hashCode();
							var pos2 = _this2.h[key1];
							if(pos2 == null) {
								throw new js__$Boot_HaxeError(Std.string(seq2) + " not in map!");
							}
							if(pos1 > pos2) {
								var swap = pos1;
								pos1 = pos2;
								pos2 = swap;
							}
							ret = _this.mValues[pos1 + pos2 * _this.mWidth];
						}
						result = ret;
					} else {
						if((seq2.mSeq == null ? 0 : seq2.mSeq.length) != (seq1.mSeq == null ? 0 : seq1.mSeq.length)) {
							throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
						}
						var score = 0;
						var count1 = 0;
						var _g11 = 0;
						var _g4 = seq1.mSeq == null ? 0 : seq1.mSeq.length;
						while(_g11 < _g4) {
							var i1 = _g11++;
							var c11 = seq1.mSeq.charAt(i1);
							var c2 = seq2.mSeq.charAt(i1);
							if(!(c11 == "-" || c11 == "A" || c11 == "T" || c11 == "G" || c11 == "C") || !(c2 == "-" || c2 == "A" || c2 == "T" || c2 == "G" || c2 == "C")) {
								continue;
							}
							if(c11 != c2) {
								++score;
							}
							++count1;
						}
						var res = count1 == 0 ? 1.0 : score / count1;
						result = res;
					}
					diff += result;
					++d;
				}
			}
			++c1;
		}
	}
	var pairwiseDistance = count == 0 ? 0 : diff / count;
	var pi = 0;
	if(n == 1) {
		n = 2;
	}
	if(pairwiseDistance == 0) {
		var _this3 = seqs.first();
		var seqLen = _this3.mSeq == null ? 0 : _this3.mSeq.length;
		pairwiseDistance = 1 / seqLen;
		pi = 2 / (seqLen * (n - 1) * (n - 1));
	} else {
		pi = pairwiseDistance * n / (n - 1);
	}
	return pi / (1 - 4 * pi / 3);
};
kretha_FourTimesRule.getBestSubClades = function(subCladeA,subCladeB,c) {
	var l = new List();
	l.add(subCladeA.first());
	l.add(subCladeB.first());
	return l;
};
kretha_FourTimesRule.mergeSpecies = function(cladeA,cladeB,spA,spB,l) {
	var _g_head = cladeA.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var lA = val;
		if(lA == spA) {
			continue;
		}
		l.add(lA);
	}
	var _g_head1 = cladeB.h;
	while(_g_head1 != null) {
		var val1 = _g_head1.item;
		_g_head1 = _g_head1.next;
		var lB = val1;
		if(lB == spB) {
			continue;
		}
		l.add(lB);
	}
	var u = new List();
	var _g_head2 = spA.h;
	while(_g_head2 != null) {
		var val2 = _g_head2.item;
		_g_head2 = _g_head2.next;
		var n1 = val2;
		u.add(n1);
	}
	var _g_head3 = spB.h;
	while(_g_head3 != null) {
		var val3 = _g_head3.item;
		_g_head3 = _g_head3.next;
		var n2 = val3;
		u.add(n2);
	}
	l.add(u);
};
kretha_FourTimesRule.seqsInClade = function(c) {
	var l = new List();
	var _this = c.mConnectedInfo;
	var seq = __map_reserved["sequence"] != null ? _this.getReserved("sequence") : _this.h["sequence"];
	if(seq != null) {
		l.add(seq);
	}
	var _g_head = c.mChilds.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var subClade = val;
		var subL = kretha_FourTimesRule.seqsInClade(subClade);
		var _g_head1 = subL.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var s = val1;
			l.add(s);
		}
	}
	var _this1 = c.mConnectedInfo;
	if(__map_reserved["seqNames"] != null) {
		_this1.setReserved("seqNames",l);
	} else {
		_this1.h["seqNames"] = l;
	}
	return l;
};
kretha_FourTimesRule.floatToStringPrecision = function(n,prec) {
	n = Math.round(n * Math.pow(10,prec));
	var str = "" + n;
	var len = str.length;
	if(len <= prec) {
		while(len < prec) {
			str = "0" + str;
			++len;
		}
		return "0." + str;
	} else {
		return HxOverrides.substr(str,0,str.length - prec) + "." + HxOverrides.substr(str,str.length - prec,null);
	}
};
kretha_FourTimesRule.speciesInClade = function(c,decisionRatio) {
	var l = new List();
	if(c.mChilds.length == 0) {
		var _this = c.mConnectedInfo;
		l.add(__map_reserved["seqNames"] != null ? _this.getReserved("seqNames") : _this.h["seqNames"]);
		var _this1 = c.mConnectedInfo;
		var value = l.first();
		if(__map_reserved["psppl"] != null) {
			_this1.setReserved("psppl",value);
		} else {
			_this1.h["psppl"] = value;
		}
		return l;
	}
	var s = new List();
	var _g_head = c.mChilds.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var child = val;
		var sub = kretha_FourTimesRule.speciesInClade(child,decisionRatio);
		s.add(sub);
	}
	if(s.length != 2) {
		throw new js__$Boot_HaxeError("WTF?");
	}
	var sA = s.first();
	var sB = s.last();
	var nSpecies = sA.length + sB.length;
	if(nSpecies == 2) {
		var bestClades = kretha_FourTimesRule.getBestSubClades(sA,sB,c);
		var seqsA = bestClades.first();
		var seqsB = bestClades.last();
		var comparisons = 0;
		var diff = 0;
		var _g_head1 = seqsA.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var seq1 = val1;
			var _g_head2 = seqsB.h;
			while(_g_head2 != null) {
				var val2 = _g_head2.item;
				_g_head2 = _g_head2.next;
				var seq2 = val2;
				var _g1 = 0;
				var _g = seq1.mNames.length;
				while(_g1 < _g) {
					var i = _g1++;
					var _g3 = 0;
					var _g2 = seq2.mNames.length;
					while(_g3 < _g2) {
						var j = _g3++;
						++comparisons;
						var result = 0;
						if(kretha_FourTimesRule.distanceMatrix != null) {
							var _this2 = kretha_FourTimesRule.distanceMatrix;
							var ret = 0;
							if(seq1 != seq2) {
								var _this3 = _this2.mNamePosLookup.values;
								var key = seq1.hashCode();
								var pos1 = _this3.h[key];
								if(pos1 == null) {
									throw new js__$Boot_HaxeError(Std.string(seq1) + " not in map!");
								}
								var _this4 = _this2.mNamePosLookup.values;
								var key1 = seq2.hashCode();
								var pos2 = _this4.h[key1];
								if(pos2 == null) {
									throw new js__$Boot_HaxeError(Std.string(seq2) + " not in map!");
								}
								if(pos1 > pos2) {
									var swap = pos1;
									pos1 = pos2;
									pos2 = swap;
								}
								ret = _this2.mValues[pos1 + pos2 * _this2.mWidth];
							}
							result = ret;
						} else {
							if((seq2.mSeq == null ? 0 : seq2.mSeq.length) != (seq1.mSeq == null ? 0 : seq1.mSeq.length)) {
								throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
							}
							var score = 0;
							var count = 0;
							var _g11 = 0;
							var _g4 = seq1.mSeq == null ? 0 : seq1.mSeq.length;
							while(_g11 < _g4) {
								var i1 = _g11++;
								var c1 = seq1.mSeq.charAt(i1);
								var c2 = seq2.mSeq.charAt(i1);
								if(!(c1 == "-" || c1 == "A" || c1 == "T" || c1 == "G" || c1 == "C") || !(c2 == "-" || c2 == "A" || c2 == "T" || c2 == "G" || c2 == "C")) {
									continue;
								}
								if(c1 != c2) {
									++score;
								}
								++count;
							}
							var res = count == 0 ? 1.0 : score / count;
							result = res;
						}
						diff += result;
					}
				}
			}
		}
		var k = diff / comparisons;
		var seqs = bestClades.first();
		var n = 0;
		var _g_head3 = seqs.h;
		while(_g_head3 != null) {
			var val3 = _g_head3.item;
			_g_head3 = _g_head3.next;
			var seq = val3;
			n += seq.mNames.length;
		}
		var count1 = 0;
		var diff1 = 0;
		var c3 = 0;
		var _g_head4 = seqs.h;
		while(_g_head4 != null) {
			var val4 = _g_head4.item;
			_g_head4 = _g_head4.next;
			var seq11 = val4;
			var _g12 = 0;
			var _g5 = seq11.mNames.length;
			while(_g12 < _g5) {
				var i2 = _g12++;
				var d = 0;
				var _g2_head = seqs.h;
				while(_g2_head != null) {
					var val5 = _g2_head.item;
					_g2_head = _g2_head.next;
					var seq21 = val5;
					var _g31 = 0;
					var _g21 = seq21.mNames.length;
					while(_g31 < _g21) {
						var j1 = _g31++;
						if(c3 == d) {
							++d;
							continue;
						}
						++count1;
						var result1 = 0;
						if(kretha_FourTimesRule.distanceMatrix != null) {
							var _this5 = kretha_FourTimesRule.distanceMatrix;
							var ret1 = 0;
							if(seq11 != seq21) {
								var _this6 = _this5.mNamePosLookup.values;
								var key2 = seq11.hashCode();
								var pos11 = _this6.h[key2];
								if(pos11 == null) {
									throw new js__$Boot_HaxeError(Std.string(seq11) + " not in map!");
								}
								var _this7 = _this5.mNamePosLookup.values;
								var key3 = seq21.hashCode();
								var pos21 = _this7.h[key3];
								if(pos21 == null) {
									throw new js__$Boot_HaxeError(Std.string(seq21) + " not in map!");
								}
								if(pos11 > pos21) {
									var swap1 = pos11;
									pos11 = pos21;
									pos21 = swap1;
								}
								ret1 = _this5.mValues[pos11 + pos21 * _this5.mWidth];
							}
							result1 = ret1;
						} else {
							if((seq21.mSeq == null ? 0 : seq21.mSeq.length) != (seq11.mSeq == null ? 0 : seq11.mSeq.length)) {
								throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
							}
							var score1 = 0;
							var count2 = 0;
							var _g13 = 0;
							var _g6 = seq11.mSeq == null ? 0 : seq11.mSeq.length;
							while(_g13 < _g6) {
								var i3 = _g13++;
								var c11 = seq11.mSeq.charAt(i3);
								var c21 = seq21.mSeq.charAt(i3);
								if(!(c11 == "-" || c11 == "A" || c11 == "T" || c11 == "G" || c11 == "C") || !(c21 == "-" || c21 == "A" || c21 == "T" || c21 == "G" || c21 == "C")) {
									continue;
								}
								if(c11 != c21) {
									++score1;
								}
								++count2;
							}
							var res1 = count2 == 0 ? 1.0 : score1 / count2;
							result1 = res1;
						}
						diff1 += result1;
						++d;
					}
				}
				++c3;
			}
		}
		var pairwiseDistance = count1 == 0 ? 0 : diff1 / count1;
		var pi = 0;
		if(n == 1) {
			n = 2;
		}
		if(pairwiseDistance == 0) {
			var _this8 = seqs.first();
			var seqLen = _this8.mSeq == null ? 0 : _this8.mSeq.length;
			pairwiseDistance = 1 / seqLen;
			pi = 2 / (seqLen * (n - 1) * (n - 1));
		} else {
			pi = pairwiseDistance * n / (n - 1);
		}
		var theta1 = pi / (1 - 4 * pi / 3);
		var seqs1 = bestClades.last();
		var n1 = 0;
		var _g_head5 = seqs1.h;
		while(_g_head5 != null) {
			var val6 = _g_head5.item;
			_g_head5 = _g_head5.next;
			var seq3 = val6;
			n1 += seq3.mNames.length;
		}
		var count3 = 0;
		var diff2 = 0;
		var c4 = 0;
		var _g_head6 = seqs1.h;
		while(_g_head6 != null) {
			var val7 = _g_head6.item;
			_g_head6 = _g_head6.next;
			var seq12 = val7;
			var _g14 = 0;
			var _g7 = seq12.mNames.length;
			while(_g14 < _g7) {
				var i4 = _g14++;
				var d1 = 0;
				var _g2_head1 = seqs1.h;
				while(_g2_head1 != null) {
					var val8 = _g2_head1.item;
					_g2_head1 = _g2_head1.next;
					var seq22 = val8;
					var _g32 = 0;
					var _g22 = seq22.mNames.length;
					while(_g32 < _g22) {
						var j2 = _g32++;
						if(c4 == d1) {
							++d1;
							continue;
						}
						++count3;
						var result2 = 0;
						if(kretha_FourTimesRule.distanceMatrix != null) {
							var _this9 = kretha_FourTimesRule.distanceMatrix;
							var ret2 = 0;
							if(seq12 != seq22) {
								var _this10 = _this9.mNamePosLookup.values;
								var key4 = seq12.hashCode();
								var pos12 = _this10.h[key4];
								if(pos12 == null) {
									throw new js__$Boot_HaxeError(Std.string(seq12) + " not in map!");
								}
								var _this11 = _this9.mNamePosLookup.values;
								var key5 = seq22.hashCode();
								var pos22 = _this11.h[key5];
								if(pos22 == null) {
									throw new js__$Boot_HaxeError(Std.string(seq22) + " not in map!");
								}
								if(pos12 > pos22) {
									var swap2 = pos12;
									pos12 = pos22;
									pos22 = swap2;
								}
								ret2 = _this9.mValues[pos12 + pos22 * _this9.mWidth];
							}
							result2 = ret2;
						} else {
							if((seq22.mSeq == null ? 0 : seq22.mSeq.length) != (seq12.mSeq == null ? 0 : seq12.mSeq.length)) {
								throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
							}
							var score2 = 0;
							var count4 = 0;
							var _g15 = 0;
							var _g8 = seq12.mSeq == null ? 0 : seq12.mSeq.length;
							while(_g15 < _g8) {
								var i5 = _g15++;
								var c12 = seq12.mSeq.charAt(i5);
								var c22 = seq22.mSeq.charAt(i5);
								if(!(c12 == "-" || c12 == "A" || c12 == "T" || c12 == "G" || c12 == "C") || !(c22 == "-" || c22 == "A" || c22 == "T" || c22 == "G" || c22 == "C")) {
									continue;
								}
								if(c12 != c22) {
									++score2;
								}
								++count4;
							}
							var res2 = count4 == 0 ? 1.0 : score2 / count4;
							result2 = res2;
						}
						diff2 += result2;
						++d1;
					}
				}
				++c4;
			}
		}
		var pairwiseDistance1 = count3 == 0 ? 0 : diff2 / count3;
		var pi1 = 0;
		if(n1 == 1) {
			n1 = 2;
		}
		if(pairwiseDistance1 == 0) {
			var _this12 = seqs1.first();
			var seqLen1 = _this12.mSeq == null ? 0 : _this12.mSeq.length;
			pairwiseDistance1 = 1 / seqLen1;
			pi1 = 2 / (seqLen1 * (n1 - 1) * (n1 - 1));
		} else {
			pi1 = pairwiseDistance1 * n1 / (n1 - 1);
		}
		var theta2 = pi1 / (1 - 4 * pi1 / 3);
		var info = kretha_FourTimesRule.floatToStringPrecision(theta1,5) + " " + kretha_FourTimesRule.floatToStringPrecision(theta2,5);
		c.mInfo.add(info);
		var theta = theta1 > theta2 ? theta1 : theta2;
		if(theta != -1) {
			var ratio = k / theta;
			var info1 = kretha_FourTimesRule.floatToStringPrecision(k,5) + "/" + kretha_FourTimesRule.floatToStringPrecision(theta,5) + "=" + kretha_FourTimesRule.floatToStringPrecision(ratio,5);
			c.mInfo.add(info1);
			if(ratio >= decisionRatio) {
				var _g_head7 = sA.h;
				while(_g_head7 != null) {
					var val9 = _g_head7.item;
					_g_head7 = _g_head7.next;
					var n11 = val9;
					l.add(n11);
				}
				var _g_head8 = sB.h;
				while(_g_head8 != null) {
					var val10 = _g_head8.item;
					_g_head8 = _g_head8.next;
					var n2 = val10;
					l.add(n2);
				}
			} else {
				kretha_FourTimesRule.mergeSpecies(sA,sB,bestClades.first(),bestClades.last(),l);
			}
		} else {
			kretha_FourTimesRule.mergeSpecies(sA,sB,bestClades.first(),bestClades.last(),l);
		}
		if(l.length == 1) {
			var _this13 = c.mConnectedInfo;
			var value1 = l.first();
			if(__map_reserved["psppl"] != null) {
				_this13.setReserved("psppl",value1);
			} else {
				_this13.h["psppl"] = value1;
			}
		}
	} else if(nSpecies == 3) {
		var sameCount = 0;
		var sX = null;
		var sY = null;
		var _g_head9 = sA.h;
		while(_g_head9 != null) {
			var val11 = _g_head9.item;
			_g_head9 = _g_head9.next;
			var s1 = val11;
			var _g_head10 = sB.h;
			while(_g_head10 != null) {
				var val12 = _g_head10.item;
				_g_head10 = _g_head10.next;
				var s2 = val12;
				var comparisons1 = 0;
				var diff3 = 0;
				var _g_head11 = s1.h;
				while(_g_head11 != null) {
					var val13 = _g_head11.item;
					_g_head11 = _g_head11.next;
					var seq13 = val13;
					var _g_head12 = s2.h;
					while(_g_head12 != null) {
						var val14 = _g_head12.item;
						_g_head12 = _g_head12.next;
						var seq23 = val14;
						var _g16 = 0;
						var _g9 = seq13.mNames.length;
						while(_g16 < _g9) {
							var i6 = _g16++;
							var _g33 = 0;
							var _g23 = seq23.mNames.length;
							while(_g33 < _g23) {
								var j3 = _g33++;
								++comparisons1;
								var result3 = 0;
								if(kretha_FourTimesRule.distanceMatrix != null) {
									var _this14 = kretha_FourTimesRule.distanceMatrix;
									var ret3 = 0;
									if(seq13 != seq23) {
										var _this15 = _this14.mNamePosLookup.values;
										var key6 = seq13.hashCode();
										var pos13 = _this15.h[key6];
										if(pos13 == null) {
											throw new js__$Boot_HaxeError(Std.string(seq13) + " not in map!");
										}
										var _this16 = _this14.mNamePosLookup.values;
										var key7 = seq23.hashCode();
										var pos23 = _this16.h[key7];
										if(pos23 == null) {
											throw new js__$Boot_HaxeError(Std.string(seq23) + " not in map!");
										}
										if(pos13 > pos23) {
											var swap3 = pos13;
											pos13 = pos23;
											pos23 = swap3;
										}
										ret3 = _this14.mValues[pos13 + pos23 * _this14.mWidth];
									}
									result3 = ret3;
								} else {
									if((seq23.mSeq == null ? 0 : seq23.mSeq.length) != (seq13.mSeq == null ? 0 : seq13.mSeq.length)) {
										throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
									}
									var score3 = 0;
									var count5 = 0;
									var _g17 = 0;
									var _g10 = seq13.mSeq == null ? 0 : seq13.mSeq.length;
									while(_g17 < _g10) {
										var i7 = _g17++;
										var c13 = seq13.mSeq.charAt(i7);
										var c23 = seq23.mSeq.charAt(i7);
										if(!(c13 == "-" || c13 == "A" || c13 == "T" || c13 == "G" || c13 == "C") || !(c23 == "-" || c23 == "A" || c23 == "T" || c23 == "G" || c23 == "C")) {
											continue;
										}
										if(c13 != c23) {
											++score3;
										}
										++count5;
									}
									var res3 = count5 == 0 ? 1.0 : score3 / count5;
									result3 = res3;
								}
								diff3 += result3;
							}
						}
					}
				}
				var k1 = diff3 / comparisons1;
				var n3 = 0;
				var _g_head13 = s1.h;
				while(_g_head13 != null) {
					var val15 = _g_head13.item;
					_g_head13 = _g_head13.next;
					var seq4 = val15;
					n3 += seq4.mNames.length;
				}
				var count6 = 0;
				var diff4 = 0;
				var c5 = 0;
				var _g_head14 = s1.h;
				while(_g_head14 != null) {
					var val16 = _g_head14.item;
					_g_head14 = _g_head14.next;
					var seq14 = val16;
					var _g18 = 0;
					var _g19 = seq14.mNames.length;
					while(_g18 < _g19) {
						var i8 = _g18++;
						var d2 = 0;
						var _g2_head2 = s1.h;
						while(_g2_head2 != null) {
							var val17 = _g2_head2.item;
							_g2_head2 = _g2_head2.next;
							var seq24 = val17;
							var _g34 = 0;
							var _g24 = seq24.mNames.length;
							while(_g34 < _g24) {
								var j4 = _g34++;
								if(c5 == d2) {
									++d2;
									continue;
								}
								++count6;
								var result4 = 0;
								if(kretha_FourTimesRule.distanceMatrix != null) {
									var _this17 = kretha_FourTimesRule.distanceMatrix;
									var ret4 = 0;
									if(seq14 != seq24) {
										var _this18 = _this17.mNamePosLookup.values;
										var key8 = seq14.hashCode();
										var pos14 = _this18.h[key8];
										if(pos14 == null) {
											throw new js__$Boot_HaxeError(Std.string(seq14) + " not in map!");
										}
										var _this19 = _this17.mNamePosLookup.values;
										var key9 = seq24.hashCode();
										var pos24 = _this19.h[key9];
										if(pos24 == null) {
											throw new js__$Boot_HaxeError(Std.string(seq24) + " not in map!");
										}
										if(pos14 > pos24) {
											var swap4 = pos14;
											pos14 = pos24;
											pos24 = swap4;
										}
										ret4 = _this17.mValues[pos14 + pos24 * _this17.mWidth];
									}
									result4 = ret4;
								} else {
									if((seq24.mSeq == null ? 0 : seq24.mSeq.length) != (seq14.mSeq == null ? 0 : seq14.mSeq.length)) {
										throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
									}
									var score4 = 0;
									var count7 = 0;
									var _g110 = 0;
									var _g20 = seq14.mSeq == null ? 0 : seq14.mSeq.length;
									while(_g110 < _g20) {
										var i9 = _g110++;
										var c14 = seq14.mSeq.charAt(i9);
										var c24 = seq24.mSeq.charAt(i9);
										if(!(c14 == "-" || c14 == "A" || c14 == "T" || c14 == "G" || c14 == "C") || !(c24 == "-" || c24 == "A" || c24 == "T" || c24 == "G" || c24 == "C")) {
											continue;
										}
										if(c14 != c24) {
											++score4;
										}
										++count7;
									}
									var res4 = count7 == 0 ? 1.0 : score4 / count7;
									result4 = res4;
								}
								diff4 += result4;
								++d2;
							}
						}
						++c5;
					}
				}
				var pairwiseDistance2 = count6 == 0 ? 0 : diff4 / count6;
				var pi2 = 0;
				if(n3 == 1) {
					n3 = 2;
				}
				if(pairwiseDistance2 == 0) {
					var _this20 = s1.first();
					var seqLen2 = _this20.mSeq == null ? 0 : _this20.mSeq.length;
					pairwiseDistance2 = 1 / seqLen2;
					pi2 = 2 / (seqLen2 * (n3 - 1) * (n3 - 1));
				} else {
					pi2 = pairwiseDistance2 * n3 / (n3 - 1);
				}
				var theta11 = pi2 / (1 - 4 * pi2 / 3);
				var n4 = 0;
				var _g_head15 = s2.h;
				while(_g_head15 != null) {
					var val18 = _g_head15.item;
					_g_head15 = _g_head15.next;
					var seq5 = val18;
					n4 += seq5.mNames.length;
				}
				var count8 = 0;
				var diff5 = 0;
				var c6 = 0;
				var _g_head16 = s2.h;
				while(_g_head16 != null) {
					var val19 = _g_head16.item;
					_g_head16 = _g_head16.next;
					var seq15 = val19;
					var _g111 = 0;
					var _g25 = seq15.mNames.length;
					while(_g111 < _g25) {
						var i10 = _g111++;
						var d3 = 0;
						var _g2_head3 = s2.h;
						while(_g2_head3 != null) {
							var val20 = _g2_head3.item;
							_g2_head3 = _g2_head3.next;
							var seq25 = val20;
							var _g35 = 0;
							var _g26 = seq25.mNames.length;
							while(_g35 < _g26) {
								var j5 = _g35++;
								if(c6 == d3) {
									++d3;
									continue;
								}
								++count8;
								var result5 = 0;
								if(kretha_FourTimesRule.distanceMatrix != null) {
									var _this21 = kretha_FourTimesRule.distanceMatrix;
									var ret5 = 0;
									if(seq15 != seq25) {
										var _this22 = _this21.mNamePosLookup.values;
										var key10 = seq15.hashCode();
										var pos15 = _this22.h[key10];
										if(pos15 == null) {
											throw new js__$Boot_HaxeError(Std.string(seq15) + " not in map!");
										}
										var _this23 = _this21.mNamePosLookup.values;
										var key11 = seq25.hashCode();
										var pos25 = _this23.h[key11];
										if(pos25 == null) {
											throw new js__$Boot_HaxeError(Std.string(seq25) + " not in map!");
										}
										if(pos15 > pos25) {
											var swap5 = pos15;
											pos15 = pos25;
											pos25 = swap5;
										}
										ret5 = _this21.mValues[pos15 + pos25 * _this21.mWidth];
									}
									result5 = ret5;
								} else {
									if((seq25.mSeq == null ? 0 : seq25.mSeq.length) != (seq15.mSeq == null ? 0 : seq15.mSeq.length)) {
										throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
									}
									var score5 = 0;
									var count9 = 0;
									var _g112 = 0;
									var _g27 = seq15.mSeq == null ? 0 : seq15.mSeq.length;
									while(_g112 < _g27) {
										var i11 = _g112++;
										var c15 = seq15.mSeq.charAt(i11);
										var c25 = seq25.mSeq.charAt(i11);
										if(!(c15 == "-" || c15 == "A" || c15 == "T" || c15 == "G" || c15 == "C") || !(c25 == "-" || c25 == "A" || c25 == "T" || c25 == "G" || c25 == "C")) {
											continue;
										}
										if(c15 != c25) {
											++score5;
										}
										++count9;
									}
									var res5 = count9 == 0 ? 1.0 : score5 / count9;
									result5 = res5;
								}
								diff5 += result5;
								++d3;
							}
						}
						++c6;
					}
				}
				var pairwiseDistance3 = count8 == 0 ? 0 : diff5 / count8;
				var pi3 = 0;
				if(n4 == 1) {
					n4 = 2;
				}
				if(pairwiseDistance3 == 0) {
					var _this24 = s2.first();
					var seqLen3 = _this24.mSeq == null ? 0 : _this24.mSeq.length;
					pairwiseDistance3 = 1 / seqLen3;
					pi3 = 2 / (seqLen3 * (n4 - 1) * (n4 - 1));
				} else {
					pi3 = pairwiseDistance3 * n4 / (n4 - 1);
				}
				var theta21 = pi3 / (1 - 4 * pi3 / 3);
				var info2 = kretha_FourTimesRule.floatToStringPrecision(theta11,5) + " " + kretha_FourTimesRule.floatToStringPrecision(theta21,5);
				c.mInfo.add(info2);
				var theta3 = theta11 > theta21 ? theta11 : theta21;
				if(theta3 != -1) {
					var ratio1 = k1 / theta3;
					var info3 = kretha_FourTimesRule.floatToStringPrecision(k1,5) + "/" + kretha_FourTimesRule.floatToStringPrecision(theta3,5) + "=" + kretha_FourTimesRule.floatToStringPrecision(ratio1,5);
					c.mInfo.add(info3);
					if(ratio1 >= decisionRatio) {
						++sameCount;
						sX = s1;
						sY = s2;
					}
				}
			}
		}
		if(sameCount == 0) {
			var _g_head17 = sA.h;
			while(_g_head17 != null) {
				var val21 = _g_head17.item;
				_g_head17 = _g_head17.next;
				var n12 = val21;
				l.add(n12);
			}
			var _g_head18 = sB.h;
			while(_g_head18 != null) {
				var val22 = _g_head18.item;
				_g_head18 = _g_head18.next;
				var n21 = val22;
				l.add(n21);
			}
		} else if(sameCount == 1) {
			var ll1 = new List();
			var ll2 = new List();
			var _g_head19 = sX.h;
			while(_g_head19 != null) {
				var val23 = _g_head19.item;
				_g_head19 = _g_head19.next;
				var n5 = val23;
				ll1.add(n5);
			}
			var _g_head20 = sY.h;
			while(_g_head20 != null) {
				var val24 = _g_head20.item;
				_g_head20 = _g_head20.next;
				var n6 = val24;
				ll1.add(n6);
			}
			var _g_head21 = sA.h;
			while(_g_head21 != null) {
				var val25 = _g_head21.item;
				_g_head21 = _g_head21.next;
				var s3 = val25;
				if(s3 != sX && s3 != sY) {
					ll2 = s3;
				}
			}
			var _g_head22 = sB.h;
			while(_g_head22 != null) {
				var val26 = _g_head22.item;
				_g_head22 = _g_head22.next;
				var s4 = val26;
				if(s4 != sX && s4 != sY) {
					ll2 = s4;
				}
			}
			l.add(ll1);
			l.add(ll2);
		} else {
			var ll = new List();
			var _g_head23 = sA.h;
			while(_g_head23 != null) {
				var val27 = _g_head23.item;
				_g_head23 = _g_head23.next;
				var n13 = val27;
				var _g_head24 = n13.h;
				while(_g_head24 != null) {
					var val28 = _g_head24.item;
					_g_head24 = _g_head24.next;
					var ind = val28;
					ll.add(ind);
				}
			}
			var _g_head25 = sB.h;
			while(_g_head25 != null) {
				var val29 = _g_head25.item;
				_g_head25 = _g_head25.next;
				var n22 = val29;
				var _g_head26 = n22.h;
				while(_g_head26 != null) {
					var val30 = _g_head26.item;
					_g_head26 = _g_head26.next;
					var ind1 = val30;
					ll.add(ind1);
				}
			}
			l.add(ll);
		}
	} else {
		var _g_head27 = sA.h;
		while(_g_head27 != null) {
			var val31 = _g_head27.item;
			_g_head27 = _g_head27.next;
			var n14 = val31;
			l.add(n14);
		}
		var _g_head28 = sB.h;
		while(_g_head28 != null) {
			var val32 = _g_head28.item;
			_g_head28 = _g_head28.next;
			var n23 = val32;
			l.add(n23);
		}
	}
	return l;
};
kretha_FourTimesRule.doRule = function(c,decisionRatio) {
	kretha_FourTimesRule.seqsInClade(c);
	return kretha_FourTimesRule.speciesInClade(c,decisionRatio);
};
var kretha_Graph = function(nodeInfo) {
	var this1 = new haxe_ds__$HashMap_HashMapData();
	this.mNodes = this1;
	if(nodeInfo != null) {
		var _g = 0;
		while(_g < nodeInfo.length) {
			var node = nodeInfo[_g];
			++_g;
			var gn = new kretha_GraphNode(node);
			var this2 = this.mNodes;
			var _this = this2.keys;
			var key = node.hashCode();
			_this.h[key] = node;
			var _this1 = this2.values;
			var key1 = node.hashCode();
			_this1.h[key1] = gn;
		}
	}
};
kretha_Graph.__name__ = true;
kretha_Graph.prototype = {
	getLeafs: function() {
		var result = new List();
		var node = this.mNodes.values.iterator();
		while(node.hasNext()) {
			var node1 = node.next();
			var ele = node1.mEleObject;
			if(node1.mConnectedEdges.length >= 2) {
				continue;
			}
			result.add(ele);
		}
		return result;
	}
	,addNode: function(ele) {
		var gn = new kretha_GraphNode(ele);
		var this1 = this.mNodes;
		var _this = this1.keys;
		var key = ele.hashCode();
		_this.h[key] = ele;
		var _this1 = this1.values;
		var key1 = ele.hashCode();
		_this1.h[key1] = gn;
	}
	,exists: function(ele) {
		var _this = this.mNodes.values;
		var key = ele.hashCode();
		return _this.h.hasOwnProperty(key);
	}
	,addEdge: function(x,y,val) {
		var _this = this.mNodes.values;
		var key = x.hashCode();
		var v1 = _this.h[key];
		if(v1 == null) {
			throw new js__$Boot_HaxeError(Std.string(x) + " not in graph!");
		}
		var _this1 = this.mNodes.values;
		var key1 = y.hashCode();
		var v2 = _this1.h[key1];
		if(v2 == null) {
			throw new js__$Boot_HaxeError(Std.string(y) + " not in graph!");
		}
		v1.addEdge(v2,val);
		v2.addEdge(v1,val);
	}
	,getEdges: function(x) {
		var _this = this.mNodes.values;
		var key = x.hashCode();
		var v1 = _this.h[key];
		if(v1 == null) {
			throw new js__$Boot_HaxeError(Std.string(x) + " not in graph!");
		}
		return v1.getEdges();
	}
	,getConnection: function(x,y) {
		var _this = this.mNodes.values;
		var key = x.hashCode();
		var v1 = _this.h[key];
		var _this1 = this.mNodes.values;
		var key1 = y.hashCode();
		var v2 = _this1.h[key1];
		return v1.getEdge(v2);
	}
	,getGraphDotRepresentation: function() {
		var result = new List();
		var this1 = new haxe_ds__$HashMap_HashMapData();
		var seen = this1;
		result.add("graph {");
		var node = this.mNodes.values.iterator();
		while(node.hasNext()) {
			var node1 = node.next();
			var ele = node1.mEleObject;
			var _g_head = node1.getEdges().h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var edge = val;
				var _this = seen.values;
				var key = edge.v.hashCode();
				if(_this.h.hasOwnProperty(key)) {
					continue;
				}
				result.add("  " + ele.getNodeName() + " -- " + edge.v.getNodeName() + " [label=\"" + Std.string(edge.e) + "\"];");
			}
			var _this1 = seen.keys;
			var key1 = ele.hashCode();
			_this1.h[key1] = ele;
			var _this2 = seen.values;
			var key2 = ele.hashCode();
			_this2.h[key2] = true;
		}
		result.add("}");
		return result.join("\n");
	}
	,__class__: kretha_Graph
};
var kretha_GraphNode = function(ele) {
	this.mEleObject = ele;
	this.mConnectedEdges = new List();
};
kretha_GraphNode.__name__ = true;
kretha_GraphNode.prototype = {
	getElement: function() {
		return this.mEleObject;
	}
	,addEdge: function(other,e) {
		var _g_head = this.mConnectedEdges.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var edge = val;
			if(edge.node == other) {
				edge.e = e;
				return;
			}
		}
		this.mConnectedEdges.add({ node : other, e : e});
	}
	,isConnectedTo: function(other) {
		var _g_head = this.mConnectedEdges.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var edge = val;
			if(edge.node == other) {
				return true;
			}
		}
		return false;
	}
	,getEdge: function(other) {
		var _g_head = this.mConnectedEdges.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var edge = val;
			if(edge.node == other) {
				return edge.e;
			}
		}
		return null;
	}
	,getEdges: function() {
		var result = new List();
		var _g_head = this.mConnectedEdges.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var edge = val;
			result.add({ v : edge.node.mEleObject, e : edge.e});
		}
		return result;
	}
	,countConnections: function() {
		return this.mConnectedEdges.length;
	}
	,__class__: kretha_GraphNode
};
var kretha_Kretha = function() { };
kretha_Kretha.__name__ = true;
kretha_Kretha.onMessage = function(e) {
	var result = new haxe_ds_StringMap();
	try {
		var fileContent = js_Boot.__cast(e.data.txt , String);
		var decisionRatio = js_Boot.__cast(e.data.decisionRatio , Float);
		var g = null;
		if(fileContent.charAt(0) == ">" || fileContent.charAt(0) == ";") {
			var reader = new kretha_FastaAlignmentReader();
			var seqs = reader.readSequences(fileContent);
			g = kretha_NeighborJoining.run(seqs);
		} else {
			var reader1 = new kretha_DistanceMatrixReader();
			var d = reader1.readMatrix(fileContent);
			g = kretha_NeighborJoining.runOnMatrix(d);
			kretha_FourTimesRule.distanceMatrix = d;
		}
		var c = kretha_MidPointRooter.root(g);
		var s = kretha_FourTimesRule.doRule(c,decisionRatio);
		var resL = kretha_Kretha.formatSpeciesList(s);
		kretha_CladeColorer.colorClades(c,s);
		var svg = c.getSVG();
		if(__map_reserved["svg"] != null) {
			result.setReserved("svg",svg);
		} else {
			result.h["svg"] = svg;
		}
		if(__map_reserved["putativeSpecies"] != null) {
			result.setReserved("putativeSpecies",resL);
		} else {
			result.h["putativeSpecies"] = resL;
		}
	} catch( e1 ) {
		if (e1 instanceof js__$Boot_HaxeError) e1 = e1.val;
		console.log(e1);
		var value = "The following error occurred: " + Std.string(e1);
		if(__map_reserved["svg"] != null) {
			result.setReserved("svg",value);
		} else {
			result.h["svg"] = value;
		}
		if(__map_reserved["putativeSpecies"] != null) {
			result.setReserved("putativeSpecies","");
		} else {
			result.h["putativeSpecies"] = "";
		}
	}
	kretha_Kretha.workerScope.postMessage(result);
};
kretha_Kretha.formatSpeciesList = function(s) {
	var result = new List();
	var i = 1;
	var _g_head = s.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var subList = val;
		var _g_head1 = subList.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var e = val1;
			var _g_head2 = e.mNames.h;
			while(_g_head2 != null) {
				var val2 = _g_head2.item;
				_g_head2 = _g_head2.next;
				var name = val2;
				result.add(name + "\t" + i);
			}
		}
		++i;
	}
	return result.join("\n");
};
kretha_Kretha.main = function() {
	kretha_Kretha.workerScope = self;
	kretha_Kretha.workerScope.onmessage = kretha_Kretha.onMessage;
};
var kretha_MidPointRooter = function() { };
kretha_MidPointRooter.__name__ = true;
kretha_MidPointRooter.getLongestPath = function(g,current,commingFrom) {
	var bestLength = 0;
	var path = null;
	var _g_head;
	var _this = g.mNodes.values;
	var key = current.hashCode();
	var v1 = _this.h[key];
	if(v1 == null) {
		throw new js__$Boot_HaxeError(Std.string(current) + " not in graph!");
	}
	_g_head = v1.getEdges().h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var connection = val;
		if(connection.v == commingFrom) {
			continue;
		}
		var alternative = kretha_MidPointRooter.getLongestPath(g,connection.v,current);
		var l = alternative.l + connection.e;
		if(l > bestLength) {
			bestLength = l;
			path = alternative.path;
		}
	}
	if(path == null) {
		path = new List();
	}
	path.add(current);
	return { path : path, l : bestLength};
};
kretha_MidPointRooter.findLongestDistance = function(g) {
	var result = null;
	var _g_head = g.getLeafs().h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var seq = val;
		var alternativeResult = kretha_MidPointRooter.getLongestPath(g,seq,null);
		if(result == null || result.l < alternativeResult.l) {
			result = alternativeResult;
		}
	}
	return result;
};
kretha_MidPointRooter.findMidPoint = function(g) {
	var result = kretha_MidPointRooter.findLongestDistance(g);
	console.log("Longest path: " + Std.string(result.path) + " with length " + result.l);
	var midLen = result.l / 2;
	var sum = 0;
	var conLen = 0;
	var oldS = null;
	var newS = null;
	var _g_head = result.path.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var s = val;
		oldS = newS;
		newS = s;
		if(oldS == null) {
			continue;
		}
		var _this = g.mNodes.values;
		var key = newS.hashCode();
		var v1 = _this.h[key];
		var _this1 = g.mNodes.values;
		var key1 = oldS.hashCode();
		var v2 = _this1.h[key1];
		conLen = v1.getEdge(v2);
		sum += conLen;
		if(sum > midLen) {
			break;
		}
	}
	return { n1 : oldS, n2 : newS, a : conLen - (sum - midLen), b : sum - midLen};
};
kretha_MidPointRooter.root = function(g) {
	var midPoint = kretha_MidPointRooter.findMidPoint(g);
	console.log("midPoint: " + Std.string(midPoint));
	var rootClade = new kretha_Clade();
	rootClade.mInfo.add("Root");
	kretha_MidPointRooter.genSubClade(g,midPoint.n1,midPoint.n2,rootClade,midPoint.a,0);
	kretha_MidPointRooter.genSubClade(g,midPoint.n2,midPoint.n1,rootClade,midPoint.b,0);
	return rootClade;
};
kretha_MidPointRooter.genSubClade = function(g,process,commingFrom,parentClade,dist,lvl) {
	var _this = g.mNodes.values;
	var key = process.hashCode();
	var v1 = _this.h[key];
	if(v1 == null) {
		throw new js__$Boot_HaxeError(Std.string(process) + " not in graph!");
	}
	var connections = v1.getEdges();
	var clade = new kretha_Clade();
	var seq = process.mSeq;
	if(seq != null) {
		var _this1 = clade.mConnectedInfo;
		if(__map_reserved["sequence"] != null) {
			_this1.setReserved("sequence",process);
		} else {
			_this1.h["sequence"] = process;
		}
	}
	var result = null;
	if(process.mNames == null || process.mNames.length == 0) {
		result = "noName";
	} else if(process.mNames.length == 1) {
		result = process.mNames.first();
	} else {
		result = process.mNames.join(",");
	}
	clade.mInfo.add(result);
	clade.mParent = parentClade;
	clade.mDist = dist;
	parentClade.mChilds.add(clade);
	var _g_head;
	var _this2 = g.mNodes.values;
	var key1 = process.hashCode();
	var v11 = _this2.h[key1];
	if(v11 == null) {
		throw new js__$Boot_HaxeError(Std.string(process) + " not in graph!");
	}
	_g_head = v11.getEdges().h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var connection = val;
		if(connection.v == commingFrom) {
			continue;
		}
		kretha_MidPointRooter.genSubClade(g,connection.v,process,clade,connection.e,lvl + 1);
	}
};
var kretha_NeighborJoining = function() { };
kretha_NeighborJoining.__name__ = true;
kretha_NeighborJoining.run = function(seqs) {
	var length = seqs.length;
	var this1 = new Array(length);
	var r = this1;
	haxe_ds__$Vector_Vector_$Impl_$.blit(seqs,0,r,0,seqs.length);
	var endPoints = r;
	var nrIndividuals = seqs.length;
	var d = new kretha_DistanceMatrix(endPoints);
	var _g = 0;
	while(_g < endPoints.length) {
		var ind1 = endPoints[_g];
		++_g;
		var _g1 = 0;
		while(_g1 < endPoints.length) {
			var ind2 = endPoints[_g1];
			++_g1;
			if(ind1 == ind2) {
				break;
			}
			if((ind2.mSeq == null ? 0 : ind2.mSeq.length) != (ind1.mSeq == null ? 0 : ind1.mSeq.length)) {
				throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
			}
			var score = 0;
			var count = 0;
			var _g11 = 0;
			var _g2 = ind1.mSeq == null ? 0 : ind1.mSeq.length;
			while(_g11 < _g2) {
				var i = _g11++;
				var c1 = ind1.mSeq.charAt(i);
				var c2 = ind2.mSeq.charAt(i);
				if(!(c1 == "-" || c1 == "A" || c1 == "T" || c1 == "G" || c1 == "C") || !(c2 == "-" || c2 == "A" || c2 == "T" || c2 == "G" || c2 == "C")) {
					continue;
				}
				if(c1 != c2) {
					++score;
				}
				++count;
			}
			var diff = count == 0 ? 1.0 : score / count;
			if(ind1 == ind2) {
				if(diff != 0) {
					throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
				}
			}
			var _this = d.mNamePosLookup.values;
			var key = ind1.hashCode();
			var pos1 = _this.h[key];
			if(pos1 == null) {
				throw new js__$Boot_HaxeError(Std.string(ind1) + " not in map!");
			}
			var _this1 = d.mNamePosLookup.values;
			var key1 = ind2.hashCode();
			var pos2 = _this1.h[key1];
			if(pos2 == null) {
				throw new js__$Boot_HaxeError(Std.string(ind2) + " not in map!");
			}
			if(pos1 > pos2) {
				var swap = pos1;
				pos1 = pos2;
				pos2 = swap;
			}
			d.mValues[pos1 + pos2 * d.mWidth] = diff;
		}
	}
	return kretha_NeighborJoining.runOnMatrix(d);
};
kretha_NeighborJoining.runOnMatrix = function(d) {
	var endPoints = d.mNames;
	var result = new kretha_Graph(endPoints);
	var innerNumber = 0;
	while(endPoints.length > 2) {
		var this1 = new haxe_ds__$HashMap_HashMapData();
		var r = this1;
		var _g = 0;
		while(_g < endPoints.length) {
			var seq = endPoints[_g];
			++_g;
			var sum = 0;
			var _g1 = 0;
			while(_g1 < endPoints.length) {
				var otherSeq = endPoints[_g1];
				++_g1;
				var ret = 0;
				if(seq != otherSeq) {
					var _this = d.mNamePosLookup.values;
					var key = seq.hashCode();
					var pos1 = _this.h[key];
					if(pos1 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq) + " not in map!");
					}
					var _this1 = d.mNamePosLookup.values;
					var key1 = otherSeq.hashCode();
					var pos2 = _this1.h[key1];
					if(pos2 == null) {
						throw new js__$Boot_HaxeError(Std.string(otherSeq) + " not in map!");
					}
					if(pos1 > pos2) {
						var swap = pos1;
						pos1 = pos2;
						pos2 = swap;
					}
					ret = d.mValues[pos1 + pos2 * d.mWidth];
				}
				sum += ret;
			}
			var v = sum / (endPoints.length - 2);
			var _this2 = r.keys;
			var key2 = seq.hashCode();
			_this2.h[key2] = seq;
			var _this3 = r.values;
			var key3 = seq.hashCode();
			_this3.h[key3] = v;
		}
		var m = new kretha_DistanceMatrix(endPoints);
		var _g2 = 0;
		while(_g2 < endPoints.length) {
			var seq1 = endPoints[_g2];
			++_g2;
			var _this4 = r.values;
			var key4 = seq1.hashCode();
			var r_i = _this4.h[key4];
			var _g11 = 0;
			while(_g11 < endPoints.length) {
				var seq2 = endPoints[_g11];
				++_g11;
				if(seq1 == seq2) {
					break;
				}
				var _this5 = r.values;
				var key5 = seq2.hashCode();
				var r_j = _this5.h[key5];
				var ret1 = 0;
				if(seq1 != seq2) {
					var _this6 = d.mNamePosLookup.values;
					var key6 = seq1.hashCode();
					var pos11 = _this6.h[key6];
					if(pos11 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq1) + " not in map!");
					}
					var _this7 = d.mNamePosLookup.values;
					var key7 = seq2.hashCode();
					var pos21 = _this7.h[key7];
					if(pos21 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq2) + " not in map!");
					}
					if(pos11 > pos21) {
						var swap1 = pos11;
						pos11 = pos21;
						pos21 = swap1;
					}
					ret1 = d.mValues[pos11 + pos21 * d.mWidth];
				}
				var val = ret1 - (r_i + r_j);
				if(seq1 == seq2) {
					if(val != 0) {
						throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
					}
				}
				var _this8 = m.mNamePosLookup.values;
				var key8 = seq1.hashCode();
				var pos12 = _this8.h[key8];
				if(pos12 == null) {
					throw new js__$Boot_HaxeError(Std.string(seq1) + " not in map!");
				}
				var _this9 = m.mNamePosLookup.values;
				var key9 = seq2.hashCode();
				var pos22 = _this9.h[key9];
				if(pos22 == null) {
					throw new js__$Boot_HaxeError(Std.string(seq2) + " not in map!");
				}
				if(pos12 > pos22) {
					var swap2 = pos12;
					pos12 = pos22;
					pos22 = swap2;
				}
				m.mValues[pos12 + pos22 * m.mWidth] = val;
			}
		}
		var lowestSeq1 = endPoints[0];
		var lowestSeq2 = endPoints[1];
		var ret2 = 0;
		if(lowestSeq1 != lowestSeq2) {
			var _this10 = m.mNamePosLookup.values;
			var key10 = lowestSeq1.hashCode();
			var pos13 = _this10.h[key10];
			if(pos13 == null) {
				throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in map!");
			}
			var _this11 = m.mNamePosLookup.values;
			var key11 = lowestSeq2.hashCode();
			var pos23 = _this11.h[key11];
			if(pos23 == null) {
				throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in map!");
			}
			if(pos13 > pos23) {
				var swap3 = pos13;
				pos13 = pos23;
				pos23 = swap3;
			}
			ret2 = m.mValues[pos13 + pos23 * m.mWidth];
		}
		var lowestVal = ret2;
		var _g3 = 0;
		while(_g3 < endPoints.length) {
			var seq11 = endPoints[_g3];
			++_g3;
			var _g12 = 0;
			while(_g12 < endPoints.length) {
				var seq21 = endPoints[_g12];
				++_g12;
				if(seq11 == seq21) {
					break;
				}
				var ret3 = 0;
				if(seq11 != seq21) {
					var _this12 = m.mNamePosLookup.values;
					var key12 = seq11.hashCode();
					var pos14 = _this12.h[key12];
					if(pos14 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq11) + " not in map!");
					}
					var _this13 = m.mNamePosLookup.values;
					var key13 = seq21.hashCode();
					var pos24 = _this13.h[key13];
					if(pos24 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq21) + " not in map!");
					}
					if(pos14 > pos24) {
						var swap4 = pos14;
						pos14 = pos24;
						pos24 = swap4;
					}
					ret3 = m.mValues[pos14 + pos24 * m.mWidth];
				}
				var currentVal = ret3;
				if(currentVal < lowestVal) {
					lowestSeq1 = seq11;
					lowestSeq2 = seq21;
					var ret4 = 0;
					if(lowestSeq1 != lowestSeq2) {
						var _this14 = m.mNamePosLookup.values;
						var key14 = lowestSeq1.hashCode();
						var pos15 = _this14.h[key14];
						if(pos15 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in map!");
						}
						var _this15 = m.mNamePosLookup.values;
						var key15 = lowestSeq2.hashCode();
						var pos25 = _this15.h[key15];
						if(pos25 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in map!");
						}
						if(pos15 > pos25) {
							var swap5 = pos15;
							pos15 = pos25;
							pos25 = swap5;
						}
						ret4 = m.mValues[pos15 + pos25 * m.mWidth];
					}
					lowestVal = ret4;
				}
			}
		}
		var l = new List();
		l.add("Inner" + innerNumber++);
		var inner = new kretha_Sequence(l,null);
		var ret5 = 0;
		if(lowestSeq1 != lowestSeq2) {
			var _this16 = d.mNamePosLookup.values;
			var key16 = lowestSeq1.hashCode();
			var pos16 = _this16.h[key16];
			if(pos16 == null) {
				throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in map!");
			}
			var _this17 = d.mNamePosLookup.values;
			var key17 = lowestSeq2.hashCode();
			var pos26 = _this17.h[key17];
			if(pos26 == null) {
				throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in map!");
			}
			if(pos16 > pos26) {
				var swap6 = pos16;
				pos16 = pos26;
				pos26 = swap6;
			}
			ret5 = d.mValues[pos16 + pos26 * d.mWidth];
		}
		var dist = ret5;
		var _this18 = r.values;
		var key18 = lowestSeq1.hashCode();
		var v_iu = dist + _this18.h[key18];
		var _this19 = r.values;
		var key19 = lowestSeq2.hashCode();
		var v_iu1 = (v_iu - _this19.h[key19]) / 2;
		var v_ju = dist - v_iu1;
		if(v_iu1 < 0 && v_ju < 0) {
			var x_tmp = v_iu1;
			v_iu1 = -v_ju;
			v_ju = -x_tmp;
		} else {
			if(v_iu1 < 0) {
				v_ju -= v_iu1;
				v_iu1 = 0;
			}
			if(v_ju < 0) {
				v_iu1 -= v_ju;
				v_ju = 0;
			}
		}
		var gn = new kretha_GraphNode(inner);
		var this2 = result.mNodes;
		var _this20 = this2.keys;
		var key20 = inner.hashCode();
		_this20.h[key20] = inner;
		var _this21 = this2.values;
		var key21 = inner.hashCode();
		_this21.h[key21] = gn;
		var _this22 = result.mNodes.values;
		var key22 = lowestSeq1.hashCode();
		var v1 = _this22.h[key22];
		if(v1 == null) {
			throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in graph!");
		}
		var _this23 = result.mNodes.values;
		var key23 = inner.hashCode();
		var v2 = _this23.h[key23];
		if(v2 == null) {
			throw new js__$Boot_HaxeError(Std.string(inner) + " not in graph!");
		}
		v1.addEdge(v2,v_iu1);
		v2.addEdge(v1,v_iu1);
		var _this24 = result.mNodes.values;
		var key24 = lowestSeq2.hashCode();
		var v11 = _this24.h[key24];
		if(v11 == null) {
			throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in graph!");
		}
		var _this25 = result.mNodes.values;
		var key25 = inner.hashCode();
		var v21 = _this25.h[key25];
		if(v21 == null) {
			throw new js__$Boot_HaxeError(Std.string(inner) + " not in graph!");
		}
		v11.addEdge(v21,v_ju);
		v21.addEdge(v11,v_ju);
		var length = endPoints.length - 1;
		var this3 = new Array(length);
		var endPoints_new = this3;
		var idx = 0;
		var _g4 = 0;
		while(_g4 < endPoints.length) {
			var seq3 = endPoints[_g4];
			++_g4;
			if(seq3 == lowestSeq1 || seq3 == lowestSeq2) {
				continue;
			}
			endPoints_new[idx++] = seq3;
		}
		endPoints_new[idx] = inner;
		var d_new = new kretha_DistanceMatrix(endPoints_new);
		var _g5 = 0;
		while(_g5 < endPoints_new.length) {
			var seq12 = endPoints_new[_g5];
			++_g5;
			var _g13 = 0;
			while(_g13 < endPoints_new.length) {
				var seq22 = endPoints_new[_g13];
				++_g13;
				if(seq12 == seq22) {
					break;
				}
				if(seq12 == inner || seq22 == inner) {
					var k = seq12 == inner ? seq22 : seq12;
					var ret6 = 0;
					if(lowestSeq1 != k) {
						var _this26 = d.mNamePosLookup.values;
						var key26 = lowestSeq1.hashCode();
						var pos17 = _this26.h[key26];
						if(pos17 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in map!");
						}
						var _this27 = d.mNamePosLookup.values;
						var key27 = k.hashCode();
						var pos27 = _this27.h[key27];
						if(pos27 == null) {
							throw new js__$Boot_HaxeError(Std.string(k) + " not in map!");
						}
						if(pos17 > pos27) {
							var swap7 = pos17;
							pos17 = pos27;
							pos27 = swap7;
						}
						ret6 = d.mValues[pos17 + pos27 * d.mWidth];
					}
					var ret7 = 0;
					if(lowestSeq2 != k) {
						var _this28 = d.mNamePosLookup.values;
						var key28 = lowestSeq2.hashCode();
						var pos18 = _this28.h[key28];
						if(pos18 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in map!");
						}
						var _this29 = d.mNamePosLookup.values;
						var key29 = k.hashCode();
						var pos28 = _this29.h[key29];
						if(pos28 == null) {
							throw new js__$Boot_HaxeError(Std.string(k) + " not in map!");
						}
						if(pos18 > pos28) {
							var swap8 = pos18;
							pos18 = pos28;
							pos28 = swap8;
						}
						ret7 = d.mValues[pos18 + pos28 * d.mWidth];
					}
					var ret8 = 0;
					if(lowestSeq1 != lowestSeq2) {
						var _this30 = d.mNamePosLookup.values;
						var key30 = lowestSeq1.hashCode();
						var pos19 = _this30.h[key30];
						if(pos19 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq1) + " not in map!");
						}
						var _this31 = d.mNamePosLookup.values;
						var key31 = lowestSeq2.hashCode();
						var pos29 = _this31.h[key31];
						if(pos29 == null) {
							throw new js__$Boot_HaxeError(Std.string(lowestSeq2) + " not in map!");
						}
						if(pos19 > pos29) {
							var swap9 = pos19;
							pos19 = pos29;
							pos29 = swap9;
						}
						ret8 = d.mValues[pos19 + pos29 * d.mWidth];
					}
					var dist1 = (ret6 + ret7 - ret8) / 2;
					if(seq12 == seq22) {
						if(dist1 != 0) {
							throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
						}
					}
					var _this32 = d_new.mNamePosLookup.values;
					var key32 = seq12.hashCode();
					var pos110 = _this32.h[key32];
					if(pos110 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq12) + " not in map!");
					}
					var _this33 = d_new.mNamePosLookup.values;
					var key33 = seq22.hashCode();
					var pos210 = _this33.h[key33];
					if(pos210 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq22) + " not in map!");
					}
					if(pos110 > pos210) {
						var swap10 = pos110;
						pos110 = pos210;
						pos210 = swap10;
					}
					d_new.mValues[pos110 + pos210 * d_new.mWidth] = dist1;
				} else {
					var ret9 = 0;
					if(seq12 != seq22) {
						var _this34 = d.mNamePosLookup.values;
						var key34 = seq12.hashCode();
						var pos111 = _this34.h[key34];
						if(pos111 == null) {
							throw new js__$Boot_HaxeError(Std.string(seq12) + " not in map!");
						}
						var _this35 = d.mNamePosLookup.values;
						var key35 = seq22.hashCode();
						var pos211 = _this35.h[key35];
						if(pos211 == null) {
							throw new js__$Boot_HaxeError(Std.string(seq22) + " not in map!");
						}
						if(pos111 > pos211) {
							var swap11 = pos111;
							pos111 = pos211;
							pos211 = swap11;
						}
						ret9 = d.mValues[pos111 + pos211 * d.mWidth];
					}
					var dist2 = ret9;
					if(seq12 == seq22) {
						if(dist2 != 0) {
							throw new js__$Boot_HaxeError("Distance of identical objects must be 0!");
						}
					}
					var _this36 = d_new.mNamePosLookup.values;
					var key36 = seq12.hashCode();
					var pos112 = _this36.h[key36];
					if(pos112 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq12) + " not in map!");
					}
					var _this37 = d_new.mNamePosLookup.values;
					var key37 = seq22.hashCode();
					var pos212 = _this37.h[key37];
					if(pos212 == null) {
						throw new js__$Boot_HaxeError(Std.string(seq22) + " not in map!");
					}
					if(pos112 > pos212) {
						var swap12 = pos112;
						pos112 = pos212;
						pos212 = swap12;
					}
					d_new.mValues[pos112 + pos212 * d_new.mWidth] = dist2;
				}
			}
		}
		endPoints = endPoints_new;
		d = d_new;
	}
	var x1 = endPoints[0];
	var x2 = endPoints[1];
	var ret10 = 0;
	if(x1 != x2) {
		var _this38 = d.mNamePosLookup.values;
		var key38 = x1.hashCode();
		var pos113 = _this38.h[key38];
		if(pos113 == null) {
			throw new js__$Boot_HaxeError(Std.string(x1) + " not in map!");
		}
		var _this39 = d.mNamePosLookup.values;
		var key39 = x2.hashCode();
		var pos213 = _this39.h[key39];
		if(pos213 == null) {
			throw new js__$Boot_HaxeError(Std.string(x2) + " not in map!");
		}
		if(pos113 > pos213) {
			var swap13 = pos113;
			pos113 = pos213;
			pos213 = swap13;
		}
		ret10 = d.mValues[pos113 + pos213 * d.mWidth];
	}
	var dist3 = ret10;
	var x = endPoints[0];
	var y = endPoints[1];
	var _this40 = result.mNodes.values;
	var key40 = x.hashCode();
	var v12 = _this40.h[key40];
	if(v12 == null) {
		throw new js__$Boot_HaxeError(Std.string(x) + " not in graph!");
	}
	var _this41 = result.mNodes.values;
	var key41 = y.hashCode();
	var v22 = _this41.h[key41];
	if(v22 == null) {
		throw new js__$Boot_HaxeError(Std.string(y) + " not in graph!");
	}
	v12.addEdge(v22,dist3);
	v22.addEdge(v12,dist3);
	return result;
};
var kretha_Sequence = function(names,seq) {
	this.mNames = names;
	this.mSeq = seq == null ? seq : seq.toUpperCase();
	this.mHashCode = kretha_Sequence.nextHashCode;
	kretha_Sequence.nextHashCode++;
};
kretha_Sequence.__name__ = true;
kretha_Sequence.prototype = {
	getNames: function() {
		return this.mNames;
	}
	,getSequenceString: function() {
		return this.mSeq;
	}
	,getLength: function() {
		if(this.mSeq == null) {
			return 0;
		} else {
			return this.mSeq.length;
		}
	}
	,isAmbChar: function(c) {
		return !(c == "-" || c == "A" || c == "T" || c == "G" || c == "C");
	}
	,getDifferenceScore: function(o,flag) {
		if((o.mSeq == null ? 0 : o.mSeq.length) != (this.mSeq == null ? 0 : this.mSeq.length)) {
			throw new js__$Boot_HaxeError("Cannot compare sequences of different length!");
		}
		var score = 0;
		var count = 0;
		var _g1 = 0;
		var _g = this.mSeq == null ? 0 : this.mSeq.length;
		while(_g1 < _g) {
			var i = _g1++;
			var c1 = this.mSeq.charAt(i);
			var c2 = o.mSeq.charAt(i);
			if(!(c1 == "-" || c1 == "A" || c1 == "T" || c1 == "G" || c1 == "C") || !(c2 == "-" || c2 == "A" || c2 == "T" || c2 == "G" || c2 == "C")) {
				continue;
			}
			if(c1 != c2) {
				++score;
			}
			++count;
		}
		if(count == 0) {
			if(flag) {
				return score;
			}
			return 1.0;
		}
		if(flag) {
			return score;
		} else {
			return score / count;
		}
	}
	,getNodeName: function() {
		var result = null;
		if(this.mNames == null || this.mNames.length == 0) {
			result = "noName";
		} else if(this.mNames.length == 1) {
			result = this.mNames.first();
		} else {
			result = this.mNames.join(",");
		}
		return result;
	}
	,toString: function() {
		var result = null;
		if(this.mNames == null || this.mNames.length == 0) {
			result = "noName";
		} else if(this.mNames.length == 1) {
			result = this.mNames.first();
		} else {
			result = this.mNames.join(",");
		}
		return result;
	}
	,hashCode: function() {
		return this.mHashCode;
	}
	,__class__: kretha_Sequence
};
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var __map_reserved = {};
js_Boot.__toStr = ({ }).toString;
kretha_CladeColorer.colors = ["#FF0000","#00FF00","#0000FF","#CC0000","#00CC00","#0000CC","#CC6600","#99CC00","#006699","#CC9900","#00CC99","#CC00CC","#CC6699","#009933","#0033CC","#6600FF","#3333FF"];
kretha_Sequence.nextHashCode = 0;
kretha_Kretha.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
